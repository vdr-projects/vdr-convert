#!/bin/bash

# VDR-convert Copyright (C) 2014-2017 Richard Farthing

# A shell script to convert VDR recordings to ts using H264/H265 and AAC

#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Note that this script is designed for VDR format 1.x and 2.x recordings only
#
# The aim is to re-create the content as accurately as possible, including all 
# streams, audio, AD and subtitles but in more compressed content
#
# For VDR conversion/compatibility we use MPEG Transport Streams (ts) as default
# Other formats now supported via -f flag
#
# Extract of VDR V1.7.3 history - naming conventions
#The directory name for a recording has been changed from
#YYYY-MM-DD-hh[.:]mm.pr.lt.rec (pr=priority, lt=lifetime) to
#YYYY-MM-DD-hh.mm.ch-ri.rec (ch=channel, ri=resumeId).
#Priority and Lifetime are now stored in the info.vdr file with the new
#tags P and L (if no such file exists, the maximum values are assumed by
#default, which avoids inadvertently deleting a recording if disk space
#is low). No longer storing Priority and Lifetime in the directory name
#avoids starting a new recording if one of these is changed in the timer
#and the recording is re-started for some reason.
#Instead of Priority and Lifetime, the directory name now contains the
#channel number from which the recording was made, and the "resume id" of
#this instance of VDR.
#
#------------------------------------------------------------------------------
# Compatibility and requirements:
#------------------------------------------------------------------------------
# VDR 1.x - 2.2x+ recordings in PES or TS format with "info" files
# Obviously script needs write access to VDR recordings (run as vdr?).
#
# Software required
# -----------------
# Current released ffmpeg in the path (3.x tested)
# Or a patched ffmpeg for damaged (bad reception) recordings or if you want
# the ultimate quality AAC using the non-free libfdk, build ffmpeg with it
#
# For transcoding old VDR1.x recordings to the newer .ts format in H264, and for 
# portability of subtitles etc, you need the following also, in your path:
# 1) ISO13818ts from http://www.scara.com/~schirmer/o/mplex13818 (build from source)
# 2) Genindex 0.2 or later (part of this project)
# 3) For auto-uploading to an ftp server: Ncftp. Adavantage of this is it can resume
# in case the upload breaks midway. Auto-resume not always reliable: hence "redo" opt
#
# The script works around various issues with existing VDR recordings
# esp. packet timings, PTS and DTS timestamp values. However if your recordings
# are really broken, you are first likely to see failures in the subtitle tests (map fn.)
# You can either: 
#   a) use -n flag and discard subs, OR
#   b) Patch ffmpeg as specified in the README, and let ffmpeg work through.
#      Set the ffmpeg variable below to point to your patched version
#      In reality this is often produces perfect results, inc subs.
#
#------------------------------------------------------------------------------
# Revision History
#------------------------------------------------------------------------------
#
# $Log: vdr-convert,v $
# Revision 2.1  2017/04/09 12:55:43  richard
# Option to convert to H265/HEVC via new -v switch, with potential for file size 1/2 of H264, 1/4 of MPEG2
# Multiple format options in single-use/batch modes via -f flag: avi, mkv, mp4, mov, m2ts, ts, aac, m4a and mp3
# New debug function facilitated testing and the creation of an extensive player/format/stream compatibility matrix at:
#    https://projects.vdr-developer.org/projects/vdr-convert/wiki/Wiki#Compatibility
# Added support for Fraunhofer AAC codec and libmp3lame codec for mp3 via new -a switch
# Added automatic conversion of AC3/DTS streams in VDR1.x recordings (thanks for sample recording contributions from this list)
# Added automatic conversion of editing marks to .edl files for Kodi, mplayer in single-use mode
# Info, warn and error criticality for different types of problems + optional email at criticality "error"
# Conversion runtime + realtime/runtime ratio logged
# Wiki extensively updated with new options at https://projects.vdr-developer.org/projects/vdr-convert/wiki
# Various other fixes and improvements; todo's cleared
#
# Revision 1.72  2017/01/04 19:29:26  richard
# Only copy valid streams in VDR1.x files, tag mpegts as system_b
#
# Revision 1.71  2016/12/21 18:17:05  richard
# missing return value from logit
#
# Revision 1.7  2016/12/21 14:14:43  richard
# Added logging criticality to syslog messages (info, warn, err)
# Optional email of events at criticality "err" (see $email variable)
# Truncate subtitle if total filename will exceed filesystem max length (see $filesystem variable)
# Add option to manually recover broken files ( -j ) for VDR2 as well as VDR1
# Remove any " from titles and subtitles which causes errors (single ' OK)
#
# Revision 1.6  2016/12/06 12:20:20  richard
# Allow for fractional -q values (e.g. 22.5), use 'veryfast' x264 preset for 1-time transcodes (performance/size sweetspot)
#
# Revision 1.5  2016/10/03 10:24:58  richard
# Separated subs size function, add new test/compare after conversion
# Add -j (just subs) switch for easier subs extraction for use in manual reassembly
#
# Revision 1.4  2016/09/26 10:19:06  richard
# Improvement to subtitle failure logic (prefer ffmpeg status to size)
#
# Revision 1.3  2016/09/01 13:01:48  richard
# Added support for VDR1.x files
# Added extensive support for dvb subtitles
# Added options c, d, e, l, m, q, t, y
# Added in-place conversion for "keeping" (-k)
# Added tests for size, duration, indexing
# Added workarounds for poor recordings/ffmpeg
# Added lockfile to prevent multiple invocations
# All streams labelled using data from info(.vdr) file
# Stream re-ordering to accomodate typ. players
# Extensive testing on 8yr libary of recordings
# Removed most mkv/mkvmerge/HandbrakeCLI code
#
# Revision 1.2  2014/12/12 12:35:31  richard
# Support VDR2 and ts files
# Support and tag HD/SD
# Fix audio encoding parameters
# Code tidy
#
# Revision 1.1  2014/12/10 10:44:19  richard
# Initial import - as used in BKK 2014
#------------------------------------------------------------------------------

# ********************************* TODO >> **********************************
#
# Automatic test/retry FTP upload size to fix upload failures
#
# ffmpeg bug (for VDR1.x subs) https://trac.ffmpeg.org/ticket/4855
# FFmpeg bug (early exit on all types of recordings) https://trac.ffmpeg.org/ticket/5617
# FFmpeg bug (some subtitles not handled) https://trac.ffmpeg.org/ticket/5796
# FFmpeg bug (H265 aspect ratio) https://trac.ffmpeg.org/ticket/5959
#
# ********************************* << TODO ***********************************
#
# *********************** CONSTANTS / USER CONFIG ***************************** 

#This is for detailed ffmpeg output
LOGFILE='/var/log/vdr-convert.log'
log_facility='local2'

#Path to your ffmpeg including patches as required
#ffmpeg="timeout -k 5h 4h ffmpeg"
# Timeout req'd for troublesome conversions where ffmpeg can (rarely) get stuck. However causes issues when run interactively.
ffmpeg='ffmpeg'
# Override for my develeopment build incorporating patches for broken recordings
[ "$HOSTNAME" = 'ha-server' ] && ffmpeg='/opt/data/develop/FFmpeg/ffmpeg'

# Minimum filesize we bother to convert
minsize='2000000'

# Defaults in case not provided by info file
Alangstereo='eng'
Alangmono='eng'
Alangmulti='eng'
Alangsurround='eng'
ADlang='eng'
Slang='eng'
framerate=25    # 25 (DVB) or 30 for ATSC

filesystem=190  # limit filename length to 256 allowing ~60 chars for EP, DOW etc
# Check behaviour on your filesystem with unicode/UTF characters, may need adjustment

email='root'    # your email for critical error messages (optional)

# *********************** Default conversion parameters ***********************

# Tuned to give balance of reasonable size and quality
stereobitrate=128           # single use
stereobitrate_k=160         # when keeping
minbitrate=100              # Absolute min for stereo streams

#aac, 5.1 etc, BBC AAC output reported as 200
#Note due to issues around nonfree AAC encoders and need to specially compile
#ffmpeg, now just copy the audio stream if multi-channel
multibitrate=192
#likely AD stream. CBR is best for this
monobitrate=50
#Video - see https://trac.ffmpeg.org/wiki/Encode/H.264
#default, use higher for kept files. (20-21 good as long as you use medium or slower x264 preset)

# Presets can make a significant difference, esp. on x265
# (see http://www.techspot.com/article/1131-hevc-h256-enconding-playback/page7.html)
presetH264='veryfast'   # H264 sweetspot is veryfast
presetH264_k='medium'
presetH265='ultrafast'  # H265 sweetspot is ultrafast. Superfast is similar
presetH265_k='slow'     # SLOW for reduced blocky artefacts when keeping. medium is OK, but some artefacts
# CRITICAL/Blocking ffmpeg/x265 cannot handle aspect ratio switch https://trac.ffmpeg.org/ticket/5959
# H265 slow (<real time on dual core) + RPi v1 cannot handle. 
# ~25% saving if same CRF used. Claim is x264 default 23 = x265 default 28. More like 26 IMHO
# x265: CRF 26 vs. x264: CRF 23 Saves ~1/3 on veryfast preset
qualityx265=4   # for x265 add to x264 setting for similar quality to x264 (should be 5 eventually)

# The following can be overridden by command line parameters

quality=23      # single use)
quality_k=20.5  # when keeping
top=0           # optional cropping
maintain=0      # copy streams
j=0
life=8      # If recording lifetime >= this, we compress if keeping, otherwise skip to save time & energy
ftp=0       # FTP out the transcoded file
redo=0      # resend named file by FTP
keep=0      # save as named file or replace recording with compressed version
subs=1      # Subs cause us 95% of problems. Option to drop them. See ffmpeg bug #5617
delete=0    # safety - by default we don't delete originals, even if nominally "keeping" them
dif=""      # deinterlacer mode: 0=send_frame (25 fps), 1=send_field (50 fps). 
            # 15-25% file size increase but also a bit better on old/noisy analogue material
debug=0     # In debug mode, only short conversions are done, and intermediate files kept
debug_time=""
combine=0   # concatenate files before conversion. VDR1.x limit is a total 16GB (in Genindex)
vcodec=264      # 264 for H264, or 265 for HEVC and ffmpeg built with appropriate library support
acodec='aac'    # aac, libfdk_aac (if ffmpeg built with support) or libmp3lame
# libfdk is supposed to be better, but (to me) doesn't sound subjectively better.
# It's a bit faster to encode, probably by using fixed point maths

ext='ts'    # default file format extension

# ********************* Should not need to edit below here ********************

lifetime=99
meg=1048576

minsubsize=250  # kb, a subs stream smaller than this probably broken or just a few in the ads
                # Also broadcaster "cleardown" - essentially empty - packets contribute
                # This is a default, recording duration is used to calculate more accurately

# Catch piped errors
set -o pipefail
# New line
IFS=$'\n'

SECONDS=0
duration=0
ts=0

# Exists?
command -v $ffmpeg >/dev/null 2>&1 || { echo "$0 requires 'ffmpeg' but it's not in the path/config,  Aborting."; exit 1; }
ffmpeg="nice -n 19 "$ffmpeg" -y -hide_banner -nostats -probesize 250M -analyzeduration 600M -copytb 1"

#------------------------------------------------------------------------------
# STREAM PROCESSING FUNCTIONS
#------------------------------------------------------------------------------

# Must analyse separately as wrong duration returned once -copyts used (for subs)
subnumerator=2
subdenomiator=17       # =425k / hr absolute min (empirical)

function progduration {
  if [ $debug -eq 1 ]; then
    duration=$(echo $debug_time|cut -f2 -d"t" | awk -F: '{ printf "%0.f", ($1 * 3600) + ($2 * 60) + $3 }')
  else
    duration=$(eval "$ffmpeg -i "\"$1"\" 2>&1" |grep -i "duration:" |cut -f2-5 -d":" | awk -F: '{ printf "%0.f", ($1 * 3600) + ($2 * 60) + $3 }')
  fi
  if [ $duration ]; then
    echo;echo "Duration is $duration seconds"
    minsubsize=$(($duration * $subnumerator))
    minsubsize=$(($minsubsize / $subdenomiator))
  fi
}

#------------------------------------------------------------------------------
# Test and extract subs with ffmpeg
# Broken subs streams WILL cause an early exit, so test them quickly : ability to copy & their size
# $1 is input, $2 output file (when required for VDR1.x conversions, or -j option)

function subslength {
  echo;echo "Testing subtitles for problems..."
  substest=$(eval "$ffmpeg $debug_time -copyts -i "\"$1"\" -c:s copy -vn -an -dn -f mpegts "\"$2"\" 2>&1")
  [ $? -ne 0 ] && echo "ffmpeg failed subtitles stream test for $1" && return 1
  len=$(echo "$substest" |grep "subtitle:"|cut -f4 -d":"|sed 's/[^0-9]*//g')
  echo "Subs length $len kbytes OK"
  return 0
}

#------------------------------------------------------------------------------
# Analyse streams, set codecs accordingly
#------------------------------------------------------------------------------
function map() {
# $1 is filename, $2 is filename ID in the map string (0:, 1:) etc.
# $3 is process phase

# Multichannel recordings often start in stereo, e.g. in a continuity announcement
# This trick gets the ONE "best" audio stream say 5 mins in to check what it really is
# ffmpeg -loglevel quiet -ss 00:05:00 -i "00001.ts" -t 10 -c copy -vn -avoid_negative_ts 1 -f nut pipe:1 | ffmpeg -hide_banner -i pipe:0
# Also AD steam contents often missing in continuity (empty). 
# So a) check after 5 mins for 5.1, and b) probe well into the file for streams not yet running - like AD
#  bestaudio=`ffmpeg -loglevel quiet -probesize 200M -analyzeduration 200M  -ss 00:05:00 -i "$1" -t 10 -c copy -vn -avoid_negative_ts 1 -f nut pipe:1 | ffmpeg -hide_banner -i pipe:0 2>&1 |grep -i "stream #0:"`
#  echo "ffmpeg best audio is:"
#  echo "$bestaudio"

  declare -a VIDEO='()'
  declare -a AUDIO='()'
  declare -a SUBS='()'
  F_VIDEO=""
  F_AUDIO=""
  F_SUBS=""
  v_source_codec=262    # 262=H262 (MPEG2), 264=H264 (MPEG4), 265=H265 (HEVC)
  mapst=""
  echo; Repeat - 120
  echo "ffmpeg stream data for $1:"
  streams=$(eval "$ffmpeg -i "\"$1"\" 2>&1" |grep -i "stream #0:")   # Line per stream
  echo "$streams"
  for line in $streams;
  do
    stream_id=$(echo $line |cut -f2 -d":" |cut -f1 -d"[" |sed 's/[^0-9]*//g')
    bitrate=$(echo ${line##*,} | sed 's/[^0-9]*//g')
    ! [ $(echo $bitrate | sed 's/[^0-9]*//g') ] && bitrate=0     # always need a number
	if [ $(echo $line |grep -i "video") ]; then
      mapst="$mapst A:$((10000 - $bitrate)):$stream_id"   # The 'A' character & bitrate is used as a score for sorting streams later

      # I assume only 1 video stream!
      [ $(echo $line |grep -i "mpeg2video") ] && v_source_codec=262
      [ $(echo $line |grep -i "h264") ] && v_source_codec=264
      [ $(echo $line |grep -i "h265\|hevc") ] && v_source_codec=265
      [ $maintain -eq 1 ] && vcodec=$v_source_codec

      # Notes on ffmpeg video parameters:
      # ---------------------------------
      # Assumption: anything worth playing video today will handle H264 high profile 4.0, including Raspberry Pi.
      # (also Freeview HD mandates it, making it a pre-requisite)

      # yadif/bwdif deinterlace option (if interlaced) as we see interlacing crap on fast movements using Kodi or VLC
      # NOTE that yadif/bwdif outputs 1 frame per *field* (send_field=1) = 50fps PAL when set to 1. 
      # Larger file but can be better esp. on mixed old/new material. Or just leave interlaced and let player deinterlace

      # Crop option is to remove overscan crap that the broadcaster forgot to filter at the top of the picture
      # (2-4 pixels often, +check for MPEG artifacts adjacent left over).

      # -g (max keyframe gap) adjusted to improve skipping which is poor at the ffmpeg default 250.
      # -g 75 Adds about 2% to filesize, -g 50 adds ~3.5%.  12 is common in broadcast!
      # (See http://www.lighterra.com/papers/videoencodingh264)

      [ $top -gt 0 ] && crop="-vf crop=in_w:in_h-$top:0:$top"
      if [ $dif ]; then
        flags="+loop"
        deint="-vf yadif=$dif:-1:0"
      else
        flags="+loop+ilme+ildct"
      fi
	  if [ $vcodec -eq 265 ]; then
        # NOTE these params subject to change as x265 improves
        if [ $keep -eq 1 ]; then 
          q=$(echo "$quality + $qualityx265"|bc)  # FP calc, adjust CRF for x265
          preset=$presetH265_k
        else
          q=$quality        # we should normally adjust as above, but using a fast preset, best not
          preset=$presetH265
        fi
        VIDEO[$stream_id]="-c:v:stream_op libx265 -preset $preset -crf $q -g 50 -flags $flags $extras $deint $crop"
      elif [ $vcodec -eq 264 ]; then
        q=$quality
        [ $keep -eq 1 ] && preset=$presetH264_k || preset=$presetH264
        concatflags="-flags +global_header" 	        # x265 doesn't like a global header
        VIDEO[$stream_id]="-c:v:stream_op libx264 -preset $preset -profile:v high -level 4.0 -crf $q -g 50 -flags $flags $extras $deint $crop"
	  fi
      # -m flag overrides all.  ?? -copyts
      [ $maintain -eq 1 ] && VIDEO[$stream_id]="-c:v:stream_op copy -g 50 $extras $deint $crop"
# v. quick functional testing only
#		F_VIDEO="-c:v libx264 -preset ultrafast -vf scale=112:63"
#		F_VIDEO="-c:v mpeg2video"
      # end video
	fi
    if [ $maintain -eq 1 ] && [ $(echo $line |grep -i "audio") ]; then
      mapst="$mapst B:$((10000 - $bitrate)):$stream_id"
      AUDIO[$stream_id]="-c:a:stream_op copy -metadata:s:a:stream_op language=$Alangstereo"
      [ $(echo $ext |grep -i "mp3") ] && logit "Warning: audio stream copy may not work with $ext format"
    # Multichannel audio - just copy to best preserve. Can be AAC 5.1. Always put multichannel ahead of others
	elif [ $(echo $line |grep -i "audio" |grep -i "ac3\|5.1") ]; then
      mapst="$mapst C:$((10000 - $bitrate)):$stream_id"
      AUDIO[$stream_id]="-c:a:stream_op copy -metadata:s:a:stream_op language=$Alangsurround"
      [ $(echo $ext |grep -i "mp3") ] && logit "Fail: multichannel audio will not work with $ext format" "err" && quit 1
	elif [ $(echo $line |grep -i "audio" |grep -i "aac") ]; then
      # We don't use Opus/HE-AAC as barely better at bitrates we're interested in
      # AAC (e.g from HD recording) best left as is. We can't always detect AAC 5.1, and sometimes not the bitrate
      # lower the risk - just copy the stream
      if [ $keep -eq 1 ]; then
        [ ! $(echo $acodec |grep -i "aac") ] && logit "Fail: unsupported request for non-aac codec with aac source, exiting" "err" && quit 1
        mapst="$mapst D:$((10000 - $bitrate)):$stream_id"
        AUDIO[$stream_id]="-c:a:stream_op copy -metadata:s:a:stream_op language=$Alangstereo"
      else
        # Take the risk for single-use, still outside chance it's multichannel and could fail
        audio_bitrate $bitrate $3
        mapst="$mapst E:$((10000 - $outputbitrate)):$stream_id"
        AUDIO[$stream_id]="-c:a:stream_op $acodec -b:a:stream_op $outputbitrate"k" -metadata:s:a:stream_op language=$Alangstereo"
      fi
	else
      # MP2 usually, sometimes mp3. ffmpeg sometimes says "2 channels". 
      # AD stream can actually be stereo, esp in HD, or "0 channels" - a null stream, which we drop
      if [ $(echo $line |grep -i "audio" |grep -i "stereo\|2 channels") ]; then
        audio_bitrate $bitrate $3
        mapst="$mapst G:$((10000 - $outputbitrate)):$stream_id"
        AUDIO[$stream_id]="-c:a:stream_op $acodec -b:a:stream_op $outputbitrate"k" -metadata:s:a:stream_op language=$Alangstereo"
      elif [ $(echo $line |grep -i "audio" |grep -i "mono") ]; then
        # Likely the AD stream, at low bitrate. 
        # !!!AAC good at low bitrates. But sparse audio gives Kodi/VLC etc trouble, as does MP3 - so copy MP2: 0.5% hit approx!
        mapst="$mapst J:$((10000 - $bitrate)):$stream_id"
        AUDIO[$stream_id]="-c:a:stream_op copy -metadata:s:a:stream_op language=$ADlang"
      fi
      # end audio
	fi

    # Skip any dvd_sub misidentified in old VDR recordings - e.g. if .vdr files passed unprocessed
    # Can be multiple streams.
	if [ $subs -eq 1 ] && [ $(echo $line |grep -i "dvb_subtitle") ]; then
      mapst="$mapst L:10000:$stream_id"
      SUBS[$stream_id]="-c:s:stream_op copy -metadata:s:s:stream_op language=$Slang"
      # Unsure if forcing dvbsub causes trouble. Usually unhelpful: results in different size o/p
      # SUBS[$stream_id]="-c:s:stream_op dvbsub -metadata:s:s:stream_op language=$Slang"
	fi
  done

  # Order streams by initial alpha AND bitrate to fix stream order change by iso13818ts, or random broadcaster ordering
  # (many players only play the first audio stream without user intervention). Produces "best" audio first, a bit like ffmpeg
  # Note that stream ordering (as reported by ffmpeg) has been observed varying between recording files in same recording!
  echo;echo "Stream scoring: $mapst"
  saveifs=$IFS
  IFS=' '
  totalmap=$(echo "$mapst"|tr " " "\n"|sort|cut -f1,3 -d":"|tr "\n" " "|tr "[:alpha:]" "$2")
  mapping=""
  vcount=0; acount=0; scount=0

  # Build the OUTPUT maps (order of outputs)
  for m in $totalmap; 
   do
    mapping="$mapping -map $m"
    id=$(echo $m|sed -e 's/[0-9]://g')
    [ "${VIDEO[$id]}" ] && { F_VIDEO="$F_VIDEO $(echo "${VIDEO[$id]}" |sed -e "s/stream_op/$vcount/g")";vcount=$(($vcount+1));}
    [ "${AUDIO[$id]}" ] && { F_AUDIO="$F_AUDIO $(echo "${AUDIO[$id]}" |sed -e "s/stream_op/$acount/g")";acount=$(($acount+1));}
    #iff subs (enabled and actually present) we need -copyts for proper sync
    [ "${SUBS[$id]}" ] && { F_SUBS="$F_SUBS -copyts $(echo "${SUBS[$id]}" |sed -e "s/stream_op/$scount/g")";scount=$(($scount+1));}
  done
  IFS=$saveifs

  map="$map$mapping"   # Additive complete map where needed
  echo;echo "stream mapping for $1 is:"
  echo "Map:  $map"
  # Only report stream codec info when relevent
  [ ! $3 ] && echo "Video:$F_VIDEO" && echo "Audio:$F_AUDIO" && echo "Subs: $F_SUBS"

  return 0
}

#------------------------------------------------------------------------------
# Audio bitrate fixup
#------------------------------------------------------------------------------
# $1 is input bitrate, $2 is vdr-convert phase
# sometimes ffmpeg can't detect the bitrate (set to 0 earlier)

function audio_bitrate() {
  local rate=$1
  if [ "$2" ] && [ $rate -gt 0 ]; then
    outputbitrate=$rate         # copy for concat if detected
  else
    outputbitrate=$stereobitrate
    (( rate = rate * 10 ))      # AKA 192k -> 160k
    (( rate = rate / 12 ))
    # sometimes the bitrate is already lower than our target, like 128k! AAC good at low rates anyway
    [ $outputbitrate -gt $rate ] && [ $rate -gt 0 ] && outputbitrate=$rate
    [ $outputbitrate -lt $minbitrate ] && outputbitrate=$minbitrate && logit "Audio bitrate: minimum set ($outputbitrate k)"
  fi
}

#------------------------------------------------------------------------------
# Transcode
#------------------------------------------------------------------------------
# $1 is input filename, $2 is output path/filename
# returns 0 on success, 1 on fail, 2 if already in same video codec
# NOTE always need to probe as deeply else ffmpeg can miss/fail, e.g AD streams/subs

function transcode() {

  main=$1
  tempdir=$(echo "$(dirname "$1")""/temp")

  if [ $VDRtype ]; then
    # The tricky bit - getting old VDR 1.x files into a format that ffmpeg can transcode, esp. non-std dvbsubs
    # This preprocessing is v. quick, really only limited by disk accesss time, as it's just stream copying & manipulation
    # -copyts is CRITICAL to getting the timing of the final subs streams aligned properly, as opposed to approximately!
    # genindex always creates 001.vdr + index.vdr

    # NOTE an earlier version made the ts's (disk intensive) only when subs detected by genindex
    # but ffmpeg occasionally fails detection of *any* streams when given an unprocessed .vdr file
    # in case we're re-doing: genindex otherwise fails
    rm -f "$tempdir"/*.vdr || logit "could not remove $tempdir vdr files" "err"
    mkdir -p -- "$tempdir" || logit "could not create $tempdir" "err"
    [ $? -ne 0 ] && logit "Failed - cannot create working directory $tempdir" "err" && return 1
    subxsize=$(genindex -n -b -i "$1" -d "$tempdir" |grep -i "^PES: Stats" |grep -i "subtitle data" |cut -f2 -d":"|sed 's/[^0-9]*//g')
    if [ $? -ne 0 ]; then
      logit "Fail: genindex problem converting $1" "err"
      if [ $debug -eq 0 ]; then
        rm -rf "$tempdir" || logit "could not remove $tempdir" "err"
      fi
      return 1 
    else
      echo
      logit "$1 genindex extracted $subxsize kb subtitle data" "info"
      # convert to ffmpeg-compatible .ts (so ffmpeg can see the streams in an mpegts container - no dvb subs decoder for PS/PES)
      # NOTE that iso13818ts often changes the order of streams which may be relevant for audio playback - see map fn.
      # Fix this later when reassembling streams in concat
      tmpts="$tempdir/001.ts"
      nice -n 19 iso13818ts -P "$tempdir/001.vdr" 1 > "$tmpts"
      if [ $? -ne 0 ]; then
        logit "Fail: Problem converting $tempdir/001.vdr to mpegts, deleting $tmpts !" "err"
        if [ $debug -eq 0 ]; then
          rm -f $tmpts || logit "could not remove $tmpts" "err"
        fi
        return 1
      fi
      if [ $debug -eq 0 ]; then
        rm -f "$tempdir"/*.vdr || logit "could not remove temp files" "err"   # No longer reqd
      fi
      progduration $tmpts
      program_duration=$(($program_duration + $duration))   # combine all files. Must test as .ts, .vdr can fail

      if [ $subs -eq 1 ]; then
        # Subs streams: MUST DO SEPARATELY as ffmpeg has big problems extracting ALL the subs and AD sparse packets
        # (cannot currently convert a small filtered subs-only file - doesn't work)
        # Many players also have this problem - esp if the video stream is present.
        # After exhaustive testing with many flags / options, atm there's NO other way to avoid this and reliably extract ALL dvbsubs

        # Now we do the ffmpeg extract anyway, in case subs stream was really OK, and only fail if it *should* have been OK -
        # i.e. genindex extracted more than minimum expected for duration. Subslength function now does both extract & size
        # ffmpeg will fail it if stream is empty

        #adjust to transcode duration to avoid errors in debug
        if [ $debug -eq 1 ]; then
          subxsize=$(($duration * $subnumerator * $subxsize))
          subxsize=$(($subxsize / 3600 / $subdenomiator))
        fi
        subsfile="$tempdir/subs.ts"
        subslength $tmpts $subsfile
        if [ $? -ne 0 ]; then
          if [ $debug -eq 0 ]; then
            rm -f "$subsfile" || logit "could not remove $subsfile" "err"
          fi
          if [ $subxsize -gt $minsubsize ]; then
            logit "Fail: ffmpeg problem extracting subs stream(s) of $tmpts (subs size $subxsize kb), is your ffmpeg patched?" "err" && return 1
          else
            logit "Warning: only $subxsize kb subtitles in $1 (VDR 1.x), expected min. $minsubsize kb: none/broken/only in ads: none converted"
          fi
        else
          subslen=$len
          # add and map the extra subs file, so the main conversion catches it, check ffmpeg didn't drop more than 10kb subs (~1 sub)
          [ $subxsize -gt $(($subslen+10)) ] && logit "Fail: ffmpeg did not pre-process all subs for $1 (VDR 1.x, $subslen kb processed, $subxsize kb extracted), deleting $tempdir !" "err" && rm -rf "$tempdir" && return 1
          # ffmpeg used to report EXACTLY the same size, newer versions perhaps not
          [ $subxsize -ne $subslen ] && logit "Warning: ffmpeg reported different subs size to genindex (VDR 1.x) for $1 ($subslen kb vs. $subxsize kb)"
          map $subsfile 1
          map="-i \"$subsfile\" $F_SUBS $map"
          echo;echo "Final subs map is $map"
          echo
        fi
      else
        logit "Skipping subtitles in $main per command" "info"
      fi

      # subs only - for manual recovery
      [ $j -eq 1 ] && rm -f "$tmpts" && logit "Subtitles now available in $subsfile" "info" && return 2

      # Main AV stream(s). Lose any subs here, as they won't (all) copy in ONE go, nice as that would be!
      # Also required to ensure streams sync properly when combined. 

      # Need copyts on main streams to sync subs when present.  But can cause ffmpeg to exit early if no subs or DTS issues
      [ "$F_SUBS" ] && copyts="-copyts" || copyts=""

      # V2: added "-fflags +genpts" as some mpeg2 video streams don't have timestamps causing ffmpeg to complain
      # Lack of timestamps can cause jerky playback. But likely to mess up broken recordings - particularly creating mp4
#      [ $ext != "mp4" ] && genpts="-fflags +genpts" # || genpts=""
      genpts="-fflags +genpts"

      main="$tempdir/main.ts"
      cmd="$ffmpeg $genpts -i "\"$tmpts"\" $copyts -c:v copy -c:a copy -sn -dn -map 0:u "\"$main"\""
      echo "Extracting main streams with $cmd"
      sh -c $cmd
      if [ $? -ne 0 ]; then
        logit "Fail: ffmpeg problem extracting main streams of $main (VDR 1.x), deleting (check $LOGFILE)" "err"
        if [ $debug -eq 0 ]; then
          rm -f $main || logit "could not remove $main" "err"
        fi
        return 1
      fi
      if [ $debug -eq 0 ]; then
        rm -f "$tmpts" || logit "could not remove $tmpts" "err"
      fi
      map $main 0       # Additive map (add in subs file/map as reqd). NOTE Loses F_SUBS !
    fi
    #end VDR1.x
  else
    # VDR2
    progduration $main
    program_duration=$(($program_duration + $duration))   # combine all files.
    map $main 0
    if [ $subs -eq 1 ]; then
      if [ ! "$F_SUBS" ]; then
        # only report subs if there is video to support them
        [ "$F_VIDEO" ] && logit "Warning no subtitles stream found in $main: none/broken/only in ads: none converted" "warn"
      else       
        # extract subs only - for manual recovery
        [ $j -eq 1 ] && subsfile="subs.ts" || subsfile="/dev/null"
        subslength $main $subsfile
        # Quit rather than continue otherwise subs could be lost, and as subs now mapped, ffmpeg likely to fail later as well
        [ $? -ne 0 ] && logit "Fail: ffmpeg problem extracting subs stream(s) of $main, is your ffmpeg patched?" "err" && return 1
        subslen=$len
        # Now we just rely on the substest. If ffmpeg says OK, it's OK, but still warn, and just in case don't delete originals
        if [ $subslen -lt $minsubsize ]; then
          logit "Warning subtitles stream in $main is smaller than minimum expected ($subslen vs. $minsubsize kb)"
          # If VDR2, perhaps not possible to transcode with subs. Only notify further if we are deleting originals
          if [ $delete -eq 1 ]; then
            if [ $subslen -eq 0 ]; then
              # V2: now regularly seeing valid, but empty, subs streams from some broadcasters
              # like null audio streams above. In fact they are often seen in the same recording
              echo "Empty subtitles stream for $main, discarding"
            else
              # a few subs means properly suspect
              delete=0 && logit "Possible fail: not deleting originals for $main due to suspect subtitle stream size - please check" "err"
            fi
          fi
        fi
      fi
    else
      logit "Skipping subtitles in $main per command" "info"
    fi
    # subs only - for manual recovery
    [ $j -eq 1 ] && logit "Subtitles ready in $subsfile" "info" && return 2
  fi

  # The main conversion. Report mapping results to info file
  reportedvideo=$F_VIDEO
  reportedaudio=$F_AUDIO

  if [ "$F_AUDIO" ]; then     # Only if we see something meaningful (may be only audio if radio recording)
	if [ $keep -eq 1 ]; then
      # might want to compress more (even with same codec) for temp use, but never if keeping. Warn not error as auto-runs on HD recordings
      [ $v_source_codec -ge $vcodec ] && [ $maintain -eq 0 ] && logit "Skipping $main: already compressed with equal/higher codec (H$v_source_codec)" "warn" && return 2
      # LATM multiplexing matches broadcast MPEG4 SD/HD audio streams, but can't currently be demuxed to plain AAC by FFMPEG
      # So even if keeping (e.g. automatic VDR transcode), and no video, use plain AAC so can transcode again if req'd (e.g podcast)
      [ "$F_VIDEO" ] && [ $vcodec -ge 264 ] && [ $(echo $acodec |grep -i "aac") ] && latm="-mpegts_flags latm"    # H264/5 + AAC use latm
    else
      [ $v_source_codec -ge $vcodec ] && [ $maintain -eq 0 ] && logit "Note: $main: already compressed with equal/higher codec (H$v_source_codec)" "info"
	fi
    #copyts and content of F_SUBS is already in the map if/when req'd for VDR1.x files
    [ $framerate -eq 25 ] && dvbsystem="-mpegts_flags system_b"  #DVB
    cmd="$ffmpeg $debug_time -i "\"$main"\" $map $F_VIDEO $F_AUDIO $F_SUBS -f mpegts $dvbsystem $latm "\"$2"\" 2>> $LOGFILE"
	echo
    # Actual conversion (long)
	logit "Transcoding with $cmd" "info"
	sh -c $cmd
	if [ $? -ne 0 ]; then
	  logit "Fail: ffmpeg problem transcoding $input, deleting "\"$2"\" !" "err"
      rm -f "$2" || logit "could not remove "\"$2"\"" "err"
	  return 1
	fi
    # Now re-test/compare after conversion in case ffmpeg lost some (still keep for examination in case really OK)...
    # F_SUBS for VDR2 conversions, copyts for VDR1.x
    if [ "$F_SUBS" ] || [ $copyts ]; then
      subslength $2 "/dev/null"
      [ $? -ne 0 ] && return 1
      [ $(($len+10)) -lt $subslen ] && logit "Fail: ffmpeg did not process all subs for $input (input $subslen kb, output $len kb)" "err" && return 1
    fi
    # clean up
  else
	logit "Fail: Nothing to transcode for $input !" "err"
	return 1
  fi
  if [ $VDRtype ] && [ $debug -eq 0 ]; then
    rm -rf "$tempdir" || logit "could not remove $tempdir" "err"
  fi
  map=""      # clear in case we process more files
  return 0
}

#------------------------------------------------------------------------------
# V2 - EDL creation for single-use mode
# Convert marks(.vdr) to an EDL so a-n-other player can skip ads
# - Kodi or (s)mplayer can use .edl files

# marks looks like 
# 0:01:01.25 Logo start
# 0:16:29.19 Logo lost
# 0:20:50.05 moved from [0:20:59.02(31476) Logo start] by checkBlackFrameOnMark  (or doOverlapDetection...)
# ...
# 1:00:02.16 noad mark on last IFrame
#
# Kodi best describes EDL: http://kodi.wiki/view/EDL_(commercial_skipping)_and_SceneMarker_support
# Mplayer/Kodi basic format closen as simplest suitable.

# $1 is marks filename. $2 is output basename

function edl() {
  # We just pair up losts (start of ADs) and starts (resume programme) to make an EDL
  commercials=0
  local tmp lost start dif timeat
  edl=$(cat "$1")
  rm -f "$2.edl" || logit "could not remove EDL file" "err" # discard any existing
  for line in $edl;
  do
    tmp=$(echo "$line" |grep -i "logo lost"|cut -c1-15|sed 's/[^0-9:.]*//g')
    if [ $tmp ]; then
      timeat=$tmp
      lost=$(echo $tmp|tr -s '.' ':'|awk -F: '{ printf "%0.2f", ($1 * 3600) + ($2 * 60) + $3 + ($4 / rate) }' rate=$framerate)
      continue
    fi
    start=$(echo "$line" |grep -i "logo start"|cut -c1-15|sed 's/[^0-9:.]*//g'|tr -s '.' ':'|awk -F: '{ printf "%0.2f", ($1 * 3600) + ($2 * 60) + $3 + ($4 / rate) }' rate=$framerate) 
    if [ $lost ] && [ $start ]; then
      echo "$lost $start 0" >> "$2.edl" 
      dif=$(echo "$start-$lost"|bc)
      echo
      # 8 mins max commercial break
      [ ${dif%.*} -gt 480 ] && logit "$2: possible error: commerical break "$dif"s long" || echo "$2 commerical break "$dif"s long at $timeat"
      commercials=$(($commercials + 1))
      lost=""; start=""
    fi
  done
  #can be just a start & end marker pair which is no use
  if [ $commercials -lt 2 ]; then
    logit "Too few EDL marker pairs ($commercials) - no EDL file created"
    if [ $debug -eq 0 ]; then
      rm -f "$2.edl" || logit "could not remove EDL file" "err"
    fi
  fi
}

#------------------------------------------------------------------------------
# Utility functions
#------------------------------------------------------------------------------
# Upload to an ftp server for faster remote download.
# Note that ncftp is not always reliable, seems to randomly quit. 
# Ideally need to a size compare & retry function
# NCFTP debug logs don't really help

function upload() {
  logit "Uploading $1"
  sh -c "ncftpput -z -t 99 -u \"$user\" -p \"$pass\" \"$server\" \"$ftppath\" \"$1\" &"
}

function usage() {
  echo "usage: $0 --input-path | -i \"<recording.rec>\" [--keep |-k] [--combine |-c] [--delete |-d] [--acodec |-a aac|libfdk_aac|libmp3lame] [--vcodec |-v 264|265] [--format |-f <extension>] [--extras |-e \"<ffmpeg opts>\"] [--just-subs |-j] [--nosubs] |-n] [--life |-l <days>] [--maintain |-m] |--quality |-q <CRF>] [--yadif |-y 0|1] [--tsonly |-t] [--crop-top <lines>] [--ftp] [--ftp-path <target path>] [--redo] |-r ] [--server |-s] [--user |-u] [--pass |-p]"
}

function escape() { 
  sed 's/'"'"'/'"\'"'/g'
}

function Repeat() {
  printf "%${2}s\n" | sed "s/ /${1}/g" 
}

# $1 the is message, $2 is criticality. Now optionally email errors
function logit() {
  crit=$2
  [ -z "$crit" ] && crit="warn"    # default
  logger -s -p "$log_facility.$crit" -t vdr-convert "$1"
  [[ $crit = "err" ]] && [ "$email" ] && echo $1 | mail -s "vdr-convert error" $email
  return 0
}

function cleanup() {
  cmd="rm -f $TMPFILES"
  if [ $debug -eq 0 ]; then
    sh -c $cmd || logit "could not remove file(s)" "err"
  else
    echo "Without debug command=$cmd"
  fi
}

# return code 0 is OK, some stats to report, 2 is OK, but we did nothing/no meaningful stats, 1 is some kind of error
function quit() {
  rm -f "$LOCKFILE" || { logit "failed to delete $LOCKFILE" "err"; exit 1; }
  echo
  [ $1 -eq 2 ] && exit 0
  [ $1 -eq 0 ] && logit "Completed: $NAME, Runtime: $(printf "%02d:%02d:%02d" $(($SECONDS / 3600))  $((($SECONDS / 60) % 60)) $(($SECONDS % 60))) ($(printf "%.1f" $(echo "$duration/$SECONDS"|bc -l))X)"
  exit $1
}

#------------------------------------------------------------------------------
# Start of script
#------------------------------------------------------------------------------

while [ "$1" != "" ]; do
    case $1 in
        -i | --input )          shift
                                input="$1"
                                ;;
        --debug )               debug=1
                                debug_time="-t 00:02:00"
                                ;;
        --crop-top )            shift
                                top=$(echo "$1"|sed -e 's/[^0-9]//g')
                                ;;
        -a | --acodec )         shift
                                acodec=$(echo "$1"|sed -e 's/[^a-z0-9_]//g')
                                ;;
        -v | --vcodec )         shift
                                vcodec=$(echo "$1"|sed -e 's/[^0-9]//g')
                                ;;
        -c | --combine )        combine=1
                                ;;
        -d | --delete )         delete=1
                                ;;
        -e | --extras )         shift
                                extras="$1"
                                ;;
        -f | --format )         shift
                                ext=$(echo "$1"|sed -e 's/[^a-z0-9]//g')
                                ;;
        -j | --just-subs )      j=1
                                combine=1
                                ;;
        -k | --keep )           keep=1
                                quality=$quality_k
                                stereobitrate=$stereobitrate_k
                                ;;
        -l | --life )           shift
                                life=$(echo "$1"|sed -e 's/[^0-9]//g')
                                ;;
        -m | --maintain )       maintain=1         # copy streams to new container, don't transcode
                                ;;
        -n | --nosubs )         subs=0
                                ;;
        -q | --quality )        shift
                                quality=$(echo "$1"|sed -e 's/[^0-9.]//g')
                                ;;
        -y | --dif )            shift
                                dif=$(echo "$1"|sed -e 's/[^0-9]//g')
                                ;;
		-t | --tsonly )			ts=1
								;;
        --ftp  )                ftp=1
                                ;;
        -r | --redo )           redo=1
                                ;;
		--ftp-path )			shift
								ftppath="$1"
								;;
        -s | --server )         shift
                                server="$1"
                                ;;
        -u | --user )           shift
                                user="$1"
                                ;;
        -p | --pass )           shift
                                pass="$1"
                                ;;
        -h | --help )           usage
                                exit 0
                                ;;
        * )                     usage
                                exit 1
    esac
    shift
done

Repeat - 120 
echo
[ ! -d "$input" ] && logit "Recording directory '"$input"' doesn't exist!" && exit 1
[ $dif ] && [ $dif -gt 1 ] && echo "deinterlacer config must be 0 or 1" && usage && exit 1

if [ $keep -eq 1 ]; then
  command -v vdr >/dev/null 2>&1 || { echo "$0 requires 'vdr' but it's not in the path,  Aborting."; exit 1; }
  [ $ext != 'ts' ] && echo "$ext format not directly supported by VDR" && exit 1
else 
  # Not a good idea - single-use mode doesn't do enough QA
  [ $delete -eq 1 ] && echo "$0 won't delete originals in single-use mode" &&  exit 1
fi

# Adjustments to interdependent parameters
[ $ext == "mp4" ] || [ $ext == "avi" ] && [ $subs -eq 1 ] && subs=0 && logit "Warning: subs not supported in $ext format: discarded if present" "warn"
[ $vcodec -lt 264 ] || [ $vcodec -gt 265 ] && usage && exit 1
[ $top -gt 0 ] && [ $maintain -eq 1 ] && echo "Can't crop without re-encoding" && exit 1

# help Fraunhofer codec produce full(er) range - default cutoff 14kHz @low bitrates
[ $acodec == "libfdk_aac" ] && acodec="$acodec -cutoff 18000"
[ $ext == "mp3" ] && acodec="libmp3lame"

# VDR has been known to "start/stop" multiple times at the end of a recording (VPS?) - so prevent multiple instances
LOCKFILE="$input/vdr-convert.pid"

# check for existing lockfile
if [ -e "$LOCKFILE" ]; then
  # lockfile exists
  [ -r "$LOCKFILE" ] || { logit "Error: cannot read lockfile"; exit 1; }
  PID=$(cat "$LOCKFILE")
  kill -0 "$(cat "$LOCKFILE")" 2>/dev/null && { logit "Error: existing instance of $0 is already running, exiting"; exit 1; }
  # process that created lockfile is no longer running - delete lockfile
  rm -f "$LOCKFILE" || { logit "Error: failed to delete $LOCKFILE"; exit 1; }
fi

# create lockfile
echo $$ >"$LOCKFILE" || { logit "Error: cannot create lockfile for $0"; exit 1; }

logit "Processing "\"$input"\", keep=$keep, delete=$delete, combine=$combine, format=$ext, subs=$subs, extras=$extras" "info"

# VDR filetypes 1.x (PES) or 2.x (TS), based on filenames in recording directory

#vdrfiles=(`find "$1" -type f -name '*.vdr' | wc -l`)
#tsfiles=(`find "$1" -type f -name '*.ts' | wc -l`)
vdrfiles=0; tsfiles=0
vdrfiles=($(ls -1 "$input" | grep ".vdr$" |grep -o '[0-9]\{3\}'| wc -l))
tsfiles=($(ls -1 "$input" | grep ".ts$" |grep -o '[0-9]\{5\}'| wc -l))
# must have 1 data file min, ideally an info file. We don't care about index file here
[ $vdrfiles -lt 1 -a $tsfiles -lt 1 ] && logit "vdr=$vdrfiles,ts=$tsfiles : too few recording / info files!" "err" && quit 1

# Assume there are multiple files, as merging is v. quick
if [ $vdrfiles -gt 0 ]; then
 VDRtype=".vdr"
 FILES="$input/0*.vdr"
else 
 VDRtype=""
 FILES="$input/0*.ts"
fi
#count=(`echo $FILES | wc -w`)

if [ $VDRtype ]; then
  [ $ts -eq 1 ] && logit "Skipping $input, t flag and not an mpegts (VDR2.x) recording" && quit 2
  command -v genindex >/dev/null 2>&1 || { echo "$0 requires 'genindex' for VDR1.x conversions, but it's not in the path,  Aborting."; quit 1; }
  command -v iso13818ts >/dev/null 2>&1 || { echo "$0 requires 'iso13818ts' for VDR1.x conversions, but it's not in the path,  Aborting."; quit 1; }
fi

#------------------------------------------------------------------------------
# Get all relevant metadata out of the info(.vdr) file, if it exists
#------------------------------------------------------------------------------

[ -e "$input/info$VDRtype" ] && meta=$(cat "$input/info$VDRtype")

TITLE="NO TITLE"
[ "$meta" ] && for line in "$meta";
do
  #naming
  TITLE=$(echo "$line" |grep "^T" |sed -e "s/^T //")
  # optional fields - add them for improved ID
  ID[0]=$(echo "$line" |grep "^S" |sed -e "s/^S //")  #subtitle
  # Support filesystems with limited max filename size by truncating just subtitle
  l=$((${#TITLE} + ${#ID[0]}))
  [ $l -ge $filesystem ] && ID[0]=$(echo $ID[0] |cut -c1-$filesystem)...
  EP=$(echo "$line" |grep "^D" |grep -oP '(?<=Episode:).*' |cut -f1 -d"|")
  # Meta info event date, time and DOW, 3rd field - useful in file listings for offline use
  ID[2]=$(echo "$line" |grep "^E" |cut -f3 -d" " |awk '{print strftime("%F-%a_%H-%M",$1)}')

  #resolution. Just look for HD in station name - a bit simplistic, but only used for file naming
  CHAN=$(echo "$line" |grep "^C" |cut -f3-7 -d" ")
  HD=$(echo "$CHAN" |grep -o 'HD')
  fr=$(echo "$line" |grep "^F"|sed 's/[^0-9]*//g')
  [ $fr ] && framerate=$fr    # when provided

  #Stream metatdata also. Video we don't check - no lang usually associated
  X201=$(echo "$line" |grep "^X 2 01\|^X 2 02" |cut -f4 -d" ")
  X203=$(echo "$line" |grep "^X 2 03" |cut -f4 -d" ")
  X204=$(echo "$line" |grep "^X 2 04" |cut -f4 -d" ")
  X205=$(echo "$line" |grep "^X 2 05" |cut -f4 -d" ")
  X240=$(echo "$line"|grep "^X 2 40" |cut -f4 -d" ")
  X31=$(echo "$line" |grep "^X 3 1" |cut -f4 -d" ")

  [ !$VDRtype ] && lifetime=$(echo "$line" |grep "^L" |sed 's/[^0-9]*//g')
done

# There are often multiples, take the first - naff, I know
IFS=' ' read -ra X201 <<<"$X201"
[ $X201 ] && Alangmono=$X201
IFS=' ' read -ra X203 <<<"$X203" 
[ $X203 ] && Alangstereo=$X203
IFS=' ' read -ra X204 <<<"$X204" 
[ $X204 ] && Alangmulti=$X204
IFS=' ' read -ra X205 <<<"$X205" 
[ $X205 ] && Alangsurround=$X205
IFS=' ' read -ra X240 <<<"$X240"
[ $X240 ] && ADlang=$X240
IFS=' ' read -ra X31 <<<"$X31" 
[ $X31 ] && Slang=$X31

[ "$EP" ] && ID[1]=EPISODE$EP

for token in ${ID[@]}
do
  [ "$token" ] && TITLE=$(echo "$TITLE-$token")
done

if [ $VDRtype ]; then
  ROOTDIR=$(echo $(dirname "$input"))
  BASEDIR=$(echo $(basename "$input"))
  priority=$(echo $BASEDIR | cut -f4 -d".")
  lifetime=$(echo $BASEDIR | cut -f5 -d".")
fi

# Short lifetime files skipped if we are "keeping" them - save time & energy
[ $lifetime -lt $life ] && [ $keep -eq 1 ] && logit "Skipping $input, recording lifetime is $lifetime" "info" && quit 2

# Option to combine input files:
# By default we convert separately, in case a broken file fails. Combining might be less reliable,
# esp. with lots of interruptions, ffmpeg duration estimations can often get messed up.
# But results are seamless when combined - recommended with good, reliable recordings
if [ $combine -eq 1 ] && [ $vdrfiles -gt 1 -o $tsfiles -gt 1 ] && [ $redo -ne 1 ]; then
  cat $FILES > "$input/recording.orig"
  if [ $? -eq 0 ]; then
    FILES="$input/recording.orig"
  else
    logit "Failed to combine input files for $input, trying individually" && rm -f "$input/recording.orig"
  fi
fi

#------------------------------------------------------------------------------
# Conversion
#------------------------------------------------------------------------------
for f in $FILES
do
  size=$(stat -c %s "$f" )
  if [ $size -gt $minsize ]; then
    inputsize=$(($inputsize + $size))
    fileno=$(($fileno + 1))
    echo; Repeat - 120
    logit "Processing \"$f\" file $fileno, size $(($size/$meg))M..." "info"
    OUTFILE=$(echo "$TITLE-file-$fileno.ts" | tr -s "\/:?*<>\"| " '-')
    [ $keep -eq 1 ] && OUTFILE="$input/$OUTFILE" || OUTFILE="$(pwd)/$OUTFILE"   # pwd if not keeping
    TMPFILES=$(echo "$TMPFILES \"$OUTFILE"\")
    MERGEFILES=$(echo "$MERGEFILES$OUTFILE|")
    if [ $redo -eq 0 ]; then
      transcode "$f" "$OUTFILE"
      return=$?
      if [ $debug -eq 0 ] && [ $combine -eq 1 ] && [ -e "$input/recording.orig" ]; then
        rm -f "$input/recording.orig" || logit "could not remove $input/recording.orig" "err"
      fi
      [ $return -gt 0 ] && quit $return
    fi
  else
    echo;logit "Skipping $f - too small ($(($size/$meg))M). Try combining input files with -c option" "err"
    # !!!continue but no longer delete (so don't lose anything if it goes wrong)
    [ $keep -eq 1 ] && [ $delete -eq 1 ] && delete=0 && logit "No longer deleting files for $input"
  fi
done

# Map the last output file
# Why? Sometimes a stream actually has no content (e.g. AD or subs),
# even if the stream notionally existed when probed, ffmpeg usually drops it silently if empty,
# resulting in a different map in the output file. The transcode function may also drop null streams
# ffmpeg still needs a specific map to copy more than just "the best" single audio & video stream.
# For VDR1.x conversions, this also fixes the output stream mapping order 
# (audio and subs first -> video, "best" audio, other audio, subs)
# NOTE this assumes map of each transcoded file is the same, otherwise there will be trouble.

map $OUTFILE 0 1

# SD or HD?. Enhanced EPG would tell us - but not always present
if [ $F_VIDEO ]; then
  DEF=$HD
  [ ! $DEF ] && DEF="SD"
else
  [ $F_AUDIO ] && DEF="AUDIO"
fi

#------------------------------------------------------------------------------
# Merge transcoded files
#------------------------------------------------------------------------------
# Now merge them, avoid faffing about with separate files
# Concat supports some file format (container) conversions and flters, but not stream conversions
# Some filters are auto-enabled depending on output format, e.g. m4a invokes aac_adtstoasc, so I no longer need to!
# see https://www.ffmpeg.org/ffmpeg-bitstream-filters.html

NAME=$(echo "$TITLE-$DEF" | tr -s "\"" '-')
BASENAME=$(echo "$TITLE" | tr -s "\/:?*<>\"| " '-')

if [ $keep -eq 1 ]; then
  OUT[0]="$input/$BASENAME.ts"
else
  # On a "redo" can't test for type, so only use basename when ftp'ing
  [ $ftp -eq 0 -a $redo -eq 0 ] && BASENAME="$BASENAME-$DEF"
  if [ $debug -eq 1 ] && [ $ext == "ts" ]; then     # i.e. default, no ext spec'd
    # loop through and create desired formats for testing (allow multiple versions to exist by naming)
    if [ $DEF == "AUDIO" ]; then
      BASENAME="$BASENAME-$acodec"
      [ $(echo $acodec |grep -i "mp3") ] && formats=(mp3 mkv ts) || formats=(aac m4a mkv mp4 ts)
    else
      BASENAME="$BASENAME-H$vcodec-$acodec"
      # Will fail on mp4 & avi if you concat with them as formats don't support subs
      [ "$F_SUBS" ] || [ $copyts ] && formats=(mkv mov m2ts ts) || formats=(avi mkv mp4 mov m2ts ts)
    fi
  else
    formats=($ext)
  fi
  # default to current directory and convert marks to EDL files if present
  [ -f "$input/marks$VDRtype" ] && edl "$input/marks$VDRtype" "$(pwd)/$BASENAME"
  for ((i=0; i<${#formats[*]}; i++));
  do
    OUT[i]="$(pwd)/$BASENAME.${formats[i]}" 
  done
fi

if [[ $redo -eq 0 && $MERGEFILES ]]; then
  result=0; results=0
  # Do merge(s)
  for outfile in ${OUT[@]}
  do
    #ts's can be concatenated directly. Again probe deeply else can fail, esp on AD/subs. 
    # NOTE concat file better than concat stream: lipsync issues
    # -copyts??? Without it ffmpeg reports duration correctly. Possibly not with copyts
    cmd="$ffmpeg -i concat:"\"$MERGEFILES"\" -metadata title="\"$NAME"\" -metadata service_provider="\"$CHAN"\" -c copy $concatflags $map "\"$outfile"\" 2>> $LOGFILE"
    echo; Repeat - 120
    logit "Creating output with $cmd" "info"
    sh -c $cmd
    result=$?
    [ $result -eq 0 ] && msg="OK" || msg="Fail"
    outputsize=$(stat -c %s "$outfile")   # 1 file
    stats="$(($inputsize/$meg))M to $(($outputsize/$meg))M ($(echo $outputsize $inputsize | awk '{ printf "%.1f", 100 * $1 / $2 }')%)"
    [ $keep -eq 0 ] && echo && logit "Created $outfile ($stats), $msg" "info"
    results=$(($results + $result))
  done
  if [ $results -eq 0 ]; then
    # Extensive QA testing when keeping
    if [ $keep -eq 1 ]; then
      # check for duration match within 30s (empirical magic number)
      progduration $outfile
      if [ $debug -eq 0 ] && [ $(($duration + 30)) -lt $program_duration ]; then
        logit "Possible fail: $outfile, size $(($outputsize/$meg))M, is only $duration sec long, original $(($inputsize/$meg))M, with length detected as $program_duration sec" "err"
        cleanup
        quit 1
      fi
      # check for silly compression ratio, or larger, heaven forbid!)
      [ $vcodec -eq 262 ] && mult=3     # MPEG original
      [ $vcodec -eq 264 ] && mult=8     # x264: 3/8 of original
      [ $vcodec -eq 265 ] && mult=12    # x265 3/12 of original
      if [ $debug -eq 0 ] && [ $(($inputsize * 3)) -gt $(($outputsize * $mult)) -o $outputsize -gt $inputsize -a $maintain -eq 0 ]; then
        logit "Possible fail: Suspect size of $outfile, (new $(($outputsize/$meg))M vs. original $(($inputsize/$meg))M)" "err"
        # keep converted outfile, actually it may be OK
        cleanup
        quit 1
      fi
      # Save video, force a VDR reindex and check it was really successful before deleting original files
      # VDR2 will only recognise .ts's in the NEW format of directory name
      if [ $VDRtype ]; then
        # Need a new recording DIR formatted for VDR2/ts files, else VDR2 won't see it
        # TV channel starts at 1. Channel number unavailable in info.vdr (& can change), just set to 1
        # Resume ID 0 as resume different in VDR1.x
        RECDIR=$(echo "$BASEDIR" | cut -f1-3 -d".")
        RECDIR="$ROOTDIR/$RECDIR.1-0.rec"
        mkdir -p -- "$RECDIR"
        if [ $? -ne 0 ]; then
          logit "Failed - cannot create $RECDIR" "err"
          cleanup
          quit 1
        fi
        # marks don't need to change - they are time-related not stream related
        [ -f "$input/marks.vdr" ] &&  cp -f "$input/marks.vdr" "$RECDIR/marks"	
        # Add the priority and Lifetime tags to new info
        cp -f "$input/info.vdr" "$RECDIR/info"
        echo "P $priority" >> "$RECDIR/info"
        echo "L $lifetime" >> "$RECDIR/info" 		
        # no resume as format changed
      else
        # VDR2 - Save ts's and index
        RECDIR="$input"
        SAVE="$input/0*.ts"
        for f in $SAVE
        do
          mv -f "$f" "$f.orig" || logit "could not save original file(s)" "err"
        done
        mv -f "$input/index" "$input/index.orig" || logit "could not save index" "warn"
      fi
      # Only a single ts after transcoding
      mv -f "$outfile" "$RECDIR/00001.ts" || logit "could not move .ts" "err"
      # Neatness, but importantly a check that VDR will be reasonably happy to play the file - otherwise bail
      sh -c "vdr --genindex "\"$RECDIR"\""
      if [ $? -eq 0 ]; then
        echo "# Transcoded from $stats by $0 on $(date)" >> "$RECDIR/info"
        [ "$F_VIDEO" ] && echo "# Video parameters: $reportedvideo" >> "$RECDIR/info"
        [ "$F_AUDIO" ] && echo "# Audio parameters: $reportedaudio" >> "$RECDIR/info"
        logit "Created/replaced .ts and indexed $NAME ($stats)" "info"
        if [ $delete -eq 1 ]; then
          if [ $VDRtype ]; then
            # old VDR 1.x directory & content no use now
            if [ $debug -eq 0 ]; then
              rm -rf "$input" || logit "could not remove original file(s)" "err"
            fi
          else
            if [ $debug -eq 0 ]; then
              rm -f "$input"/*.orig || logit "could not remove original file(s)" "err"
            fi
          fi
          logit "Original files for $NAME deleted" "info"
        fi
      else
        # Failed, so restore
        logit "Conversion / indexing for $NAME failed" "err"
        if [ $VDRtype ]; then
          if [ $debug -eq 0 ]; then
            rm -rf "$RECDIR" || logit "could not delete temp conversion files"    # borked new directory
          fi
        else
          # Overwrite
          mv -f "$RECDIR/index.orig" "$RECDIR/index" || logit "could not restore index"
          for f in $SAVE
          do
            mv -f "$f.orig" "$f" || logit "could not restore original video file"
          done
        fi
      fi
    #end keep mode
    fi
  else
    logit "Fail: Converted files for $NAME did not merge correctly" "err"
  fi
  cleanup
fi

# FTP upload if required
[ $ftp -eq 1 -o $redo -eq 1 -a $debug -eq 0 ] && upload "$outfile"

# remove lockfile
quit 0

# --------- $Id: vdr-convert,v 2.1 2017/04/09 12:55:43 richard Exp $ ---------- END
