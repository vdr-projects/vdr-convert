#!/bin/bash

# VDR-convert Copyright (C) 2014-2018 Richard Farthing

# A shell script to convert VDR recordings to ts using H264/H265 and AAC

#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Note that this script is designed for VDR format 1.x and 2.x recordings only
#
# The aim is to re-create the content as accurately as possible, including all 
# streams, audio, AD and subtitles but in more compressed content
#
# For VDR conversion/compatibility we use MPEG Transport Streams (ts) as default
# Other formats now supported via -f flag
#
# Extract of VDR V1.7.3 history - naming conventions
#The directory name for a recording has been changed from
#YYYY-MM-DD-hh[.:]mm.pr.lt.rec (pr=priority, lt=lifetime) to
#YYYY-MM-DD-hh.mm.ch-ri.rec (ch=channel, ri=resumeId).
#Priority and Lifetime are now stored in the info.vdr file with the new
#tags P and L (if no such file exists, the maximum values are assumed by
#default, which avoids inadvertently deleting a recording if disk space
#is low). No longer storing Priority and Lifetime in the directory name
#avoids starting a new recording if one of these is changed in the timer
#and the recording is re-started for some reason.
#Instead of Priority and Lifetime, the directory name now contains the
#channel number from which the recording was made, and the "resume id" of
#this instance of VDR.
#
#------------------------------------------------------------------------------
# Compatibility and requirements:
#------------------------------------------------------------------------------
# VDR 1.x - 2.2x+ recordings in PES or TS format with "info" files
# Obviously script needs write access to VDR recordings (run as vdr?).
#
# Software required
# -----------------
# Current released ffmpeg in the path (3.x tested)
# Or a patched ffmpeg for damaged (bad reception) recordings or if you want
# the ultimate quality AAC using the non-free libfdk, build ffmpeg with it
#
# For transcoding old VDR1.x recordings to the newer .ts format in H264, and for 
# portability of subtitles etc, you need the following also, in your path:
# 1) ISO13818ts from http://www.scara.com/~schirmer/o/mplex13818 (build from source)
# 2) Genindex 0.2 or later (part of this project)
# 3) For auto-uploading to an ftp server: Ncftp. Adavantage of this is it can resume
# in case the upload breaks midway. Auto-resume not always reliable: hence "redo" opt
#
# The script works around various issues with existing VDR recordings
# esp. packet timings, PTS and DTS timestamp values. However if your recordings
# are really broken, you are first likely to see failures in the subtitle tests (map fn.)
# You can either: 
#   a) use -n flag and discard subs, OR
#   b) Patch ffmpeg as specified in the README, and let ffmpeg work through.
#      Set the ffmpeg variable below to point to your patched version
#      In reality this is often produces perfect results, inc subs.
#
#------------------------------------------------------------------------------
# Revision History
#------------------------------------------------------------------------------
#
# $Log: vdr-convert,v $
# Revision 2.2  2018/09/12 12:10:10  richard
# Added --podcast option: podcasts stored in subdirectories, by Title
# Podcast audio codec config: Can use (HE)AAC, MP3 or Opus
# Extensive embedding of metadata in output files (mainly for podcasts)
# Added -g option for genre files to define mapping of VDR's G tag to text
#
# Significant H265 setting updates to reflect recent improvements
# Slight H264 compression increase to reflect recent improvements
# More extensive checking of ffmpeg build options (codec library checks)
# Detect short initial recording files & delete (VPS aborted start)
# Various other fixes and improvements, incl. for FTP/redo modes
# Fixes for recent ffmpeg versions (3.3+)
#
# Revision 2.1  2017/04/09 12:55:43  richard
# Option to convert to H265/HEVC via new -v switch, with potential for file size 1/2 of H264, 1/4 of MPEG2
# Multiple format options in single-use/batch modes via -f flag: avi, mkv, mp4, mov, m2ts, ts, aac, m4a and mp3
# New debug function facilitated testing and the creation of an extensive player/format/stream compatibility matrix at:
#    https://projects.vdr-developer.org/projects/vdr-convert/wiki/Wiki#Compatibility
# Added support for Fraunhofer AAC codec and libmp3lame codec for mp3 via new -a switch
# Added automatic conversion of AC3/DTS streams in VDR1.x recordings (thanks for sample recording contributions from this list)
# Added automatic conversion of editing marks to .edl files for Kodi, mplayer in single-use mode
# Info, warn and error criticality for different types of problems + optional email at criticality "error"
# Conversion runtime + realtime/runtime ratio logged
# Wiki extensively updated with new options at https://projects.vdr-developer.org/projects/vdr-convert/wiki
# Various other fixes and improvements; todo's cleared
#
# Revision 1.72  2017/01/04 19:29:26  richard
# Only copy valid streams in VDR1.x files, tag mpegts as system_b
#
# Revision 1.71  2016/12/21 18:17:05  richard
# missing return value from logit
#
# Revision 1.7  2016/12/21 14:14:43  richard
# Added logging criticality to syslog messages (info, warn, err)
# Optional email of events at criticality "err" (see $email variable)
# Truncate subtitle if total filename will exceed filesystem max length (see $filesystem variable)
# Add option to manually recover broken files ( -j ) for VDR2 as well as VDR1
# Remove any " from titles and subtitles which causes errors (single ' OK)
#
# Revision 1.6  2016/12/06 12:20:20  richard
# Allow for fractional -q values (e.g. 22.5), use 'veryfast' x264 preset for 1-time transcodes (performance/size sweetspot)
#
# Revision 1.5  2016/10/03 10:24:58  richard
# Separated subs size function, add new test/compare after conversion
# Add -j (just subs) switch for easier subs extraction for use in manual reassembly
#
# Revision 1.4  2016/09/26 10:19:06  richard
# Improvement to subtitle failure logic (prefer ffmpeg status to size)
#
# Revision 1.3  2016/09/01 13:01:48  richard
# Added support for VDR1.x files
# Added extensive support for dvb subtitles
# Added options c, d, e, l, m, q, t, y
# Added in-place conversion for "keeping" (-k)
# Added tests for size, duration, indexing
# Added workarounds for poor recordings/ffmpeg
# Added lockfile to prevent multiple invocations
# All streams labelled using data from info(.vdr) file
# Stream re-ordering to accomodate typ. players
# Extensive testing on 8yr libary of recordings
# Removed most mkv/mkvmerge/HandbrakeCLI code
#
# Revision 1.2  2014/12/12 12:35:31  richard
# Support VDR2 and ts files
# Support and tag HD/SD
# Fix audio encoding parameters
# Code tidy
#
# Revision 1.1  2014/12/10 10:44:19  richard
# Initial import - as used in BKK 2014
#------------------------------------------------------------------------------

# ********************************* TODO >> **********************************
#
# Automatic test/retry FTP upload size to fix upload failures
#
# ffmpeg bug (for VDR1.x subs) https://trac.ffmpeg.org/ticket/4855
# FFmpeg bug (early exit on all types of recordings) https://trac.ffmpeg.org/ticket/5617
# FFmpeg bug (some subtitles not handled) https://trac.ffmpeg.org/ticket/5796
# FFmpeg bug (H265 aspect ratio) https://trac.ffmpeg.org/ticket/5959
#
# Improve detection of 5.1 when it's not present at the start of the recording
#
# ********************************* << TODO ***********************************
#
# *********************** CONSTANTS / USER CONFIG ***************************** 

#This is for detailed ffmpeg output
LOGFILE='/var/log/vdr-convert.log'
log_facility='local2'

#Path to your ffmpeg including patches as required
#ffmpeg="timeout -k 5h 4h ffmpeg"
# Timeout req'd for troublesome conversions where ffmpeg can (rarely) get stuck. However causes issues when run interactively.
ffmpeg='ffmpeg'
# Override for my develeopment build incorporating patches for broken recordings
myserver="ha-server"
[[ $HOSTNAME == $myserver* ]] && ffmpeg='/opt/data/develop/FFmpeg/ffmpeg' 

# Minimum filesize we bother to convert
minsize='2000000'

# Defaults in case not provided by info file
Alangstereo='eng'
Alangmono='eng'
Alangmulti='eng'
Alangsurround='eng'
ADlang='eng'
Slang='eng'
framerate=25    # 25 (DVB) or 30 for ATSC

filesystem=190  # limit filename length to 256 allowing ~60 chars for EP, DOW etc
# Check behaviour on your filesystem with unicode/UTF characters, may need adjustment

email='root'    # your email for critical error messages (optional)

# *********************** Default conversion parameters ***********************

# Tuned to give balance of reasonable size and quality
stereobitrate=120           # single use
stereobitrate_k=150         # when keeping
minbitrate=100              # Absolute min (LC) for stereo streams

#aac, 5.1 etc, BBC AAC output reported as 200
#Note due to issues around nonfree AAC encoders and need to specially compile
#ffmpeg, now just copy the audio stream if multi-channel
multibitrate=192
#likely AD stream. CBR is best for this
monobitrate=50
#Video - see https://trac.ffmpeg.org/wiki/Encode/H.264
#default, use higher for kept files. (20-21 good as long as you use medium or slower x264 preset)

# Presets can make a significant difference, esp. on x265
# (see http://www.techspot.com/article/1131-hevc-h256-enconding-playback/page7.html)
presetH264='veryfast'   # H264 sweetspot is veryfast
presetH264_k='medium'
presetH265='veryfast'  # H265 sweetspot is also now veryfast. Superfast has visible artefcts around text
presetH265_k='medium'  # medium now OK
# CRITICAL/Blocking ffmpeg/x265 cannot handle aspect ratio switch https://trac.ffmpeg.org/ticket/5959
# H265 is slow (~real time on a dual core in normal mode, even slower in keep), RPi v1 cannot handle.

qualityx265=5   # for x265 adder to x264 setting for similar quality to x264

# The following can be overridden by command line parameters

quality=23      # single use
quality_k=21    # when keeping - was 20.5, H264 improved a little
top=0           # optional cropping
maintain=0      # copy streams
j=0
life=8      # If recording lifetime >= this, we compress if keeping, otherwise skip to save time & energy
ftp=0       # FTP out the transcoded file
redo=0      # resend named file by FTP
keep=0      # save as named file or replace recording with compressed version
subs=1      # Subs cause us 95% of problems. Option to drop them. See ffmpeg bug #5617
delete=0    # safety - by default we don't delete originals, even if nominally "keeping" them
dif=""      # deinterlacer mode: 0=send_frame (25 fps), 1=send_field (50 fps). 
            # 15-25% file size increase but also a bit better on old/noisy analogue material
debug=0     # In debug mode, only short conversions are done, and intermediate files kept
debug_time=""
combine=0   # concatenate files before conversion. VDR1.x limit is a total 16GB (in Genindex)
vcodec=264      # 264 for H264, or 265 for HEVC and ffmpeg built with appropriate library support
acodec='aac'    # aac, libfdk_aac (if ffmpeg built with support) or libmp3lame, again with support
# libfdk is commonly said to be best, but (to me) doesn't sound subjectively any different
# ffmpeg themselves claim parity as of 2017. Others disagree.
# But libfdk is signifcantly faster to encode by using fixed point maths, and importantly provides HE-AAC

ext='ts'    # default file format extension

# *** Podcast settings ***
# see https://wiki.hydrogenaud.io/index.php?title=Fraunhofer_FDK_AAC
# Listening tests show that >= 32k is OK on HE-AAC v2.
# IMDA Guidelines for Broadcasters 2013: "...with a sweet spot at 48 kb/s"
# No available USAC/xHE-AAC codec yet in ffmpeg, and OPUS doesn't support 44.1kHz sample rate
# NOTE that Squeezeplayers on Joggler don't support 48k sample rate (in m4a anyway), so resample to 44.1k
# libsoxr supposed to be higher quality resampler (sounds a bit better, usu. requires custom ffmpeg build)
# MKV supports slightly better metadata, LMS doesn't recognise by default.

podcastaudioprofile="libfdk_aac -profile:a aac_he_v2 -b:a 48k -af aresample=resampler=soxr -ar 44100"
# podcastaudioprofile="libmp3lame -b:a 80k -af aresample=resampler=soxr -ar 44100"  # MP3
# podcastaudioprofile="libopus -b:a 48k"      # Opus - Can't downsample to 44.1

# Post conversion commands, e.g. to tell VDR a recording has been deleted AND
# command a Squeezeserver to rescan its library after making a new podcast. Amend as required or leave blank
podcastcmd="touch /mnt/lvm/TV/.update;curl -m 3 http://$myserver:9000/status.suffix?p0=rescan > /dev/null 2>&1"

# ********************* Should not need to edit below here ********************

lifetime=99
meg=1048576

minsubsize=250  # kb, a subs stream smaller than this probably broken or just a few in the ads
                # Also broadcaster "cleardown" - essentially empty - packets contribute
                # This is a default, recording duration is used to calculate more accurately

# Catch piped errors
set -o pipefail
# New line
IFS=$'\n'

SECONDS=0
duration=0
ts=0

#------------------------------------------------------------------------------
# STREAM PROCESSING FUNCTIONS
#------------------------------------------------------------------------------

# Must analyse separately as wrong duration returned once -copyts used (for subs)
subnumerator=2
subdenomiator=17       # =425k / hr absolute min (empirical)

function progduration {
  if [ $debug -eq 1 ]; then
    duration=$(echo $debug_time|cut -f2 -d"t" | awk -F: '{ printf "%0.f", ($1 * 3600) + ($2 * 60) + $3 }')
  else
    duration=$(eval "$ffmpeg -i "\"$1"\" 2>&1" |grep -i "duration:" |cut -f2-5 -d":" | awk -F: '{ printf "%0.f", ($1 * 3600) + ($2 * 60) + $3 }')
  fi
  if [ $duration ]; then
    echo;echo "Duration is $duration seconds"
    minsubsize=$(($duration * $subnumerator))
    minsubsize=$(($minsubsize / $subdenomiator))
  fi
}

#------------------------------------------------------------------------------
# Test and extract subs with ffmpeg
# Broken subs streams WILL cause an early exit, so test them quickly : ability to copy & their size
# $1 is input, $2 output file (when required for VDR1.x conversions, or -j option)

function subslength {
  echo;echo "Testing subtitles for problems..."
  substest=$(eval "$ffmpeg $debug_time -copyts -i "\"$1"\" -c:s copy -vn -an -dn -f mpegts "\"$2"\" 2>&1")
  [ $? -ne 0 ] && echo "ffmpeg failed subtitles stream test for $1" && return 1
  len=$(echo "$substest" |grep "subtitle:"|cut -f4 -d":"|sed 's/[^0-9]*//g')
  echo "Subs length $len kbytes OK"
  return 0
}

#------------------------------------------------------------------------------
# Analyse streams, set codecs accordingly
#------------------------------------------------------------------------------
function map() {
# $1 is filename, $2 is filename ID in the map string (0:, 1:) etc.
# $3 is process phase

# Multichannel recordings often start in stereo, e.g. in a continuity announcement
# This trick gets the ONE "best" audio stream say 5 mins in to check what it really is
# ffmpeg -loglevel quiet -ss 00:05:00 -i "00001.ts" -t 10 -c copy -vn -avoid_negative_ts 1 -f nut pipe:1 | ffmpeg -hide_banner -i pipe:0
# Also AD steam contents often missing in continuity (empty). 
# So a) check after 5 mins for 5.1, and b) probe well into the file for streams not yet running - like AD
#  bestaudio=`ffmpeg -loglevel quiet -probesize 200M -analyzeduration 200M  -ss 00:05:00 -i "$1" -t 10 -c copy -vn -avoid_negative_ts 1 -f nut pipe:1 | ffmpeg -hide_banner -i pipe:0 2>&1 |grep -i "stream #0:"`
#  echo "ffmpeg best audio is:"
#  echo "$bestaudio"

  declare -a VIDEO='()'
  declare -a AUDIO='()'
  declare -a SUBS='()'
  F_VIDEO=""
  F_AUDIO=""
  F_SUBS=""
  v_source_codec=262    # 262=H262 (MPEG2), 264=H264 (MPEG4), 265=H265 (HEVC)
  mapst=""
  echo; Repeat - 120
  echo "ffmpeg stream data for $1:"
  streams=$(eval "$ffmpeg -i "\"$1"\" 2>&1" |grep -i "stream #0:")   # Line per stream
  echo "$streams"
  for line in $streams;
  do
    stream_id=$(echo $line |cut -f2 -d":" |cut -f1 -d"[" |sed 's/[^0-9]*//g')
    bitrate=$(echo ${line##*,} | sed 's/[^0-9]*//g')
    ! [ $(echo $bitrate | sed 's/[^0-9]*//g') ] && bitrate=0     # always need a number
	if [ $(echo $line |grep -i "video") ]; then
      mapst="$mapst A:$((10000 - $bitrate)):$stream_id"   # The 'A' character & bitrate is used as a score for sorting streams later

      # I assume only 1 video stream!
      [ $(echo $line |grep -i "mpeg2video") ] && v_source_codec=262
      [ $(echo $line |grep -i "h264") ] && v_source_codec=264
      [ $(echo $line |grep -i "h265\|hevc") ] && v_source_codec=265
      if [ $maintain -eq 1 ]; then 
        vcodec=$v_source_codec
      else
        # Skip at the final mappping stage - we have encoded video then (H264 etc)
        # might want to compress more (even with same codec) for temp use, but never if keeping. Warn not error as auto-runs on HD recordings
        if [ ! $3 ] && [ $v_source_codec -ge $vcodec ]; then
          if [ $keep -eq 1 ]; then
            echo; logit "Skipping $1 already compressed with equal/higher vcodec (H$v_source_codec)" "warn" && return 2
          else 
            echo; logit "Note: $1 already compressed with equal/higher vcodec (H$v_source_codec)" "info"
          fi
        fi
      fi

      # Notes on ffmpeg video parameters:
      # ---------------------------------
      # Assumption: anything worth playing video today will handle H264 high profile 4.0, including Raspberry Pi.
      # (also Freeview HD mandates it, making it a pre-requisite)

      # yadif/bwdif deinterlace option (if interlaced) as we see interlacing crap on fast movements using Kodi or VLC
      # NOTE that yadif/bwdif outputs 1 frame per *field* (send_field=1) = 50fps PAL when set to 1. 
      # Larger file but can be better esp. on mixed old/new material. Or just leave interlaced and let player deinterlace

      # Crop option is to remove overscan crap that the broadcaster forgot to filter at the top of the picture
      # (2-4 pixels often, +check for MPEG artifacts adjacent left over).

      # -g (max keyframe gap) adjusted to improve skipping which is poor at the ffmpeg default 250.
      # -g 75 Adds about 2% to filesize, -g 50 adds ~3.5%.  12 is common in broadcast!
      # (See http://www.lighterra.com/papers/videoencodingh264)

      [ $top -gt 0 ] && crop="-vf crop=in_w:in_h-$top:0:$top"
      if [ $dif ]; then
        flags="+loop"
        deint="-vf yadif=$dif:-1:0"
      else
        flags="+loop+ilme+ildct"
      fi
	  if [ $vcodec -eq 265 ]; then
        q=$(echo "$quality + $qualityx265"|bc)  # FP calc, adjust CRF for x265
        [ $keep -eq 1 ] && preset=$presetH265_k || preset=$presetH265
        VIDEO[$stream_id]="-c:v:stream_op libx265 -preset $preset -crf $q -g 50 -flags $flags $extras $deint $crop"
      elif [ $vcodec -eq 264 ]; then
        q=$quality
        [ $keep -eq 1 ] && preset=$presetH264_k || preset=$presetH264
        concatflags="-flags +global_header" 	        # x265 doesn't like a global header
        VIDEO[$stream_id]="-c:v:stream_op libx264 -preset $preset -profile:v high -level 4.0 -crf $q -g 50 -flags $flags $extras $deint $crop"
	  fi
      # -m flag overrides all.  ?? -copyts
      [ $maintain -eq 1 ] && VIDEO[$stream_id]="-c:v:stream_op copy -g 50 $extras $deint $crop"
# v. quick functional testing only
#		F_VIDEO="-c:v libx264 -preset ultrafast -vf scale=112:63"
#		F_VIDEO="-c:v mpeg2video"
      # end video
	fi
    if [ $maintain -eq 1 ] && [ $(echo $line |grep -i "audio") ]; then
      mapst="$mapst B:$((10000 - $bitrate)):$stream_id"
      AUDIO[$stream_id]="-c:a:stream_op copy -metadata:s:a:stream_op language=$Alangstereo"
      [ $(echo $ext |grep -i "mp3") ] && logit "Warning: audio stream copy may not work with $ext format"
    # Multichannel audio - just copy to best preserve. Can be AAC 5.1. Always put multichannel ahead of others
	elif [ $(echo $line |grep -i "audio" |grep -i "ac3\|5.1") ]; then
      mapst="$mapst C:$((10000 - $bitrate)):$stream_id"
      AUDIO[$stream_id]="-c:a:stream_op copy -metadata:s:a:stream_op language=$Alangsurround"
      [ $(echo $ext |grep -i "mp3") ] && logit "Fail: multichannel audio will not work with $ext format" "err" && quit 1
	elif [ $(echo $line |grep -i "audio" |grep -i "aac") ]; then
      # We don't normally use Opus/HE-AAC as barely better at bitrates we're interested for AV transcodes. Opus is really only 48k
      # AAC (e.g from HD recording) best left as is. We can't always detect AAC 5.1 (e.g starts in continuity in stereo), sometimes not the bitrate
      # Doesn't matter how long you probe for, may still miss 5.1 AAC. Only safe way is copy

      # lower the risk - just copy the stream
      if [ $keep -eq 1 ]; then
        [ ! $(echo $acodec |grep -i "aac") ] && logit "Fail: unsupported request for non-aac codec with aac source, exiting" "err" && quit 1
        mapst="$mapst D:$((10000 - $bitrate)):$stream_id"
        AUDIO[$stream_id]="-c:a:stream_op copy -metadata:s:a:stream_op language=$Alangstereo"
      else
        # Take the risk for single-use, still an outside chance it's multichannel and could fail or end up as stereo
        audio_bitrate $bitrate $3
        mapst="$mapst E:$((10000 - $outputbitrate)):$stream_id"
        AUDIO[$stream_id]="-c:a:stream_op $acodec -b:a:stream_op $outputbitrate"k" -metadata:s:a:stream_op language=$Alangstereo"
      fi
	else
      # MP2 usually, sometimes mp3. ffmpeg sometimes says "2 channels". 
      # AD stream can actually be stereo, esp in HD, or "0 channels" - a null stream, which we drop
      if [ $(echo $line |grep -i "audio" |grep -i "stereo\|2 channels") ]; then
        audio_bitrate $bitrate $3
        mapst="$mapst G:$((10000 - $outputbitrate)):$stream_id"
        AUDIO[$stream_id]="-c:a:stream_op $acodec -b:a:stream_op $outputbitrate"k" -metadata:s:a:stream_op language=$Alangstereo"
      elif [ $(echo $line |grep -i "audio" |grep -i "mono") ]; then
        # Likely the AD stream, at low bitrate. 
        # !!!AAC good at low bitrates. But sparse audio gives Kodi/VLC etc trouble, as does MP3 - so copy MP2: 0.5% hit approx!
        mapst="$mapst J:$((10000 - $bitrate)):$stream_id"
        AUDIO[$stream_id]="-c:a:stream_op copy -metadata:s:a:stream_op language=$ADlang"
      fi
      # end audio
	fi

    # Skip any dvd_sub misidentified in old VDR recordings - e.g. if .vdr files passed unprocessed
    # Can be multiple streams.
	if [ $subs -eq 1 ] && [ $(echo $line |grep -i "dvb_subtitle") ]; then
      mapst="$mapst L:10000:$stream_id"
      SUBS[$stream_id]="-c:s:stream_op copy -metadata:s:s:stream_op language=$Slang"
      # Unsure if forcing dvbsub causes trouble. Usually unhelpful: results in different size o/p
      # SUBS[$stream_id]="-c:s:stream_op dvbsub -metadata:s:s:stream_op language=$Slang"
	fi
  done

  # Order streams by initial alpha AND bitrate to fix stream order change by iso13818ts, or random broadcaster ordering
  # (many players only play the first audio stream without user intervention). Produces "best" audio first, a bit like ffmpeg
  # Note that stream ordering (as reported by ffmpeg) has been observed varying between recording files even in same recording!
  echo;echo "Stream scoring: $mapst"
  saveifs=$IFS
  IFS=' '
  totalmap=$(echo "$mapst"|tr " " "\n"|sort|cut -f1,3 -d":"|tr "\n" " "|tr "[:alpha:]" "$2")
  mapping=""
  vcount=0; acount=0; scount=0

  # Build the OUTPUT maps (order of outputs)
  for m in $totalmap; 
   do
    mapping="$mapping -map $m"
    id=$(echo $m|sed -e 's/[0-9]://g')
    [ "${VIDEO[$id]}" ] && { F_VIDEO="$F_VIDEO $(echo "${VIDEO[$id]}" |sed -e "s/stream_op/$vcount/g")";vcount=$(($vcount+1));}
    [ "${AUDIO[$id]}" ] && { F_AUDIO="$F_AUDIO $(echo "${AUDIO[$id]}" |sed -e "s/stream_op/$acount/g")";acount=$(($acount+1));}
    #iff subs (enabled and actually present) we need -copyts for proper sync
    [ "${SUBS[$id]}" ] && { F_SUBS="$F_SUBS -copyts $(echo "${SUBS[$id]}" |sed -e "s/stream_op/$scount/g")";scount=$(($scount+1));}
  done
  IFS=$saveifs

  # Podcast mode: This is the earliest we guarantee to know that there's only audio, so we can make a decision in podcast mode:
  # replace the acodec string: drop the bitrate down and set the podcast profile [HE-AAC V2 normally]

  # If we're mapping at final merge stage,  don't zap the podcast flag etc, we may be just creating filename (e.g redo)
  if [ ! $3 ]; then
    if [ "$podcast" ]; then
      if [ ! "$F_VIDEO" ] && [ "$F_AUDIO" ]; then
        [ $acount -ne 1 ] && logit "Fail: Audio Podcast mode & audio stream count not 1: exiting" "err" && quit 1
        [ ! "$genrefile" ] && logit "Warning: Podcast requires genre definition file to create correct metadata tags" "warn"
        if [ $(echo $podcastaudioprofile | grep 'aac_he') ] && [ ! $(echo $ffmpegbuild | grep 'libfdk') ]; then
          logit "Podcast profile requires ffmpeg built with libfdk_aac for HE-AAC" && quit 1
        fi
        if [ $(echo $podcastaudioprofile | grep 'soxr') ] && [ ! $(echo $ffmpegbuild | grep 'libsoxr') ]; then
          logit "Podcast mode reqesting libsoxr but not available in this ffmpeg build - using built-in resampler" "info"
          podcastaudioprofile=$(echo $podcastaudioprofile | sed -e "s/soxr/swr/")
        fi
        if [ $ext = "ts" ]; then  # ts default, useless for podcasts: override to avoid errors or -f option
          ext="m4a"
          [ $(echo $podcastaudioprofile | grep 'libmp3') ] && ext="mp3" 
          [ $(echo $podcastaudioprofile | grep 'libopus') ] && ext="opus"
        fi
        F_AUDIO=$(echo $F_AUDIO | sed -e "s/\(-c:a:0\).*\(-metadata\)/-c:a:0 $podcastaudioprofile -metadata/")
        concatflags="-movflags +faststart" 	    # help any streaming
        keep=0      # and we not keeping it: VDR may not support HE-AAC V2
      else          # video podcast anyone ?
        if [ $keep -eq 0 ]; then
          # Not a good idea - single-use modes don't do enough QA
          [ $delete -eq 1 ] && delete=0 && logit "Won't delete originals in single-use modes" "warn"
        else
          ext="ts"  # force ts in keep mode for VDR compatibility. No codec adjustments
        fi
      fi
    else
      if [ $keep -eq 0 ]; then
        [ $delete -eq 1 ] && delete=0 && logit "Won't delete originals in single-use modes" "warn"
      else
        ext="ts"
      fi
    fi
    # Only report stream codec info when actually relevent/correct
    echo "Video:$F_VIDEO" && echo "Audio:$F_AUDIO" && echo "Subs: $F_SUBS"
  fi
  map="$map$mapping"   # Additive complete map where needed
  echo;echo "stream mapping for $1:"
  echo "Map:  $map"
#  echo "debug!"; exit
  return 0
}

#------------------------------------------------------------------------------
# Audio bitrate fixup
#------------------------------------------------------------------------------
# $1 is input bitrate, $2 is vdr-convert phase
# sometimes ffmpeg can't detect the bitrate (set to 0 earlier)

function audio_bitrate() {
  local rate=$1
  if [ "$2" ] && [ $rate -gt 0 ]; then
    outputbitrate=$rate         # copy for concat if detected
  else
    outputbitrate=$stereobitrate
    (( rate = rate * 10 ))      # AKA 192k -> 160k
    (( rate = rate / 12 ))
    # sometimes the bitrate is already lower than our target, like 128k! AAC good at low rates anyway
    [ $outputbitrate -gt $rate ] && [ $rate -gt 0 ] && outputbitrate=$rate
    [ $outputbitrate -lt $minbitrate ] && outputbitrate=$minbitrate && logit "Audio bitrate: minimum set ($outputbitrate k)"
  fi
}

#------------------------------------------------------------------------------
# Transcode
#------------------------------------------------------------------------------
# $1 is input filename, $2 is output path/filename
# returns 0 on success, 1 on fail, 2 if already in same video codec
# NOTE always need to probe as deeply else ffmpeg can miss/fail, e.g AD streams/subs

function transcode() {

  main=$1
  tempdir=$(echo "$(dirname "$1")""/temp")

  if [ $VDRtype ]; then
    # The tricky bit - getting old VDR 1.x files into a format that ffmpeg can transcode, esp. non-std dvbsubs
    # This preprocessing is v. quick, really only limited by disk accesss time, as it's just stream copying & manipulation
    # -copyts is CRITICAL to getting the timing of the final subs streams aligned properly, as opposed to approximately!
    # genindex always creates 001.vdr + index.vdr

    # NOTE an earlier version made the ts's (disk intensive) only when subs detected by genindex
    # but ffmpeg occasionally fails detection of *any* streams when given an unprocessed .vdr file
    # in case we're re-doing: genindex otherwise fails
    rm -f "$tempdir"/*.vdr || logit "could not remove $tempdir vdr files" "err"
    mkdir -p -- "$tempdir" || logit "could not create $tempdir" "err"
    [ $? -ne 0 ] && logit "Failed - cannot create working directory $tempdir" "err" && return 1
    subxsize=$(genindex -n -b -i "$1" -d "$tempdir" |grep -i "^PES: Stats" |grep -i "subtitle data" |cut -f2 -d":"|sed 's/[^0-9]*//g')
    if [ $? -ne 0 ]; then
      logit "Fail: genindex problem converting $1" "err"
      if [ $debug -eq 0 ]; then
        rm -rf "$tempdir" || logit "could not remove $tempdir" "err"
      fi
      return 1 
    else
      echo
      logit "$1 genindex extracted $subxsize kb subtitle data" "info"
      # convert to ffmpeg-compatible .ts (so ffmpeg can see the streams in an mpegts container - no dvb subs decoder for PS/PES)
      # NOTE that iso13818ts often changes the order of streams which may be relevant for audio playback - see map fn.
      # Fix this later when reassembling streams in concat
      tmpts="$tempdir/001.ts"
      nice -n 19 iso13818ts -P "$tempdir/001.vdr" 1 > "$tmpts"
      if [ $? -ne 0 ]; then
        logit "Fail: Problem converting $tempdir/001.vdr to mpegts, deleting $tmpts !" "err"
        if [ $debug -eq 0 ]; then
          rm -f $tmpts || logit "could not remove $tmpts" "err"
        fi
        return 1
      fi
      if [ $debug -eq 0 ]; then
        rm -f "$tempdir"/*.vdr || logit "could not remove temp files" "err"   # No longer reqd
      fi
      progduration $tmpts
      program_duration=$(($program_duration + $duration))   # combine all files. Must test as .ts, .vdr can fail

      if [ $subs -eq 1 ]; then
        # Subs streams: MUST DO SEPARATELY as ffmpeg has big problems extracting ALL the subs and AD sparse packets
        # (cannot currently convert a small filtered subs-only file - doesn't work)
        # Many players also have this problem - esp if the video stream is present.
        # After exhaustive testing with many flags / options, atm there's NO other way to avoid this and reliably extract ALL dvbsubs

        # Now we do the ffmpeg extract anyway, in case subs stream was really OK, and only fail if it *should* have been OK -
        # i.e. genindex extracted more than minimum expected for duration. Subslength function now does both extract & size
        # ffmpeg will fail it if stream is empty

        #adjust to transcode duration to avoid errors in debug
        if [ $debug -eq 1 ]; then
          subxsize=$(($duration * $subnumerator * $subxsize))
          subxsize=$(($subxsize / 3600 / $subdenomiator))
        fi
        subsfile="$tempdir/subs.ts"
        subslength $tmpts $subsfile
        if [ $? -ne 0 ]; then
          if [ $debug -eq 0 ]; then
            rm -f "$subsfile" || logit "could not remove $subsfile" "err"
          fi
          if [ $subxsize -gt $minsubsize ]; then
            logit "Fail: ffmpeg problem extracting subs stream(s) of $tmpts (subs size $subxsize kb), is your ffmpeg patched?" "err" && return 1
          else
            logit "Warning: only $subxsize kb subtitles in $1 (VDR 1.x), expected min. $minsubsize kb: none/broken/only in ads: none converted"
          fi
        else
          subslen=$len
          # add and map the extra subs file, so the main conversion catches it, check ffmpeg didn't drop more than 10kb subs (~1 sub)
          [ $subxsize -gt $(($subslen+10)) ] && logit "Fail: ffmpeg did not pre-process all subs for $1 (VDR 1.x, $subslen kb processed, $subxsize kb extracted), deleting $tempdir !" "err" && rm -rf "$tempdir" && return 1
          # ffmpeg used to report EXACTLY the same size, newer versions perhaps not
          [ $subxsize -ne $subslen ] && logit "Warning: ffmpeg reported different subs size to genindex (VDR 1.x) for $1 ($subslen kb vs. $subxsize kb)"
          map $subsfile 1
          ret=$?
          [ $ret -gt 0 ] && logit "internal error, video in subs file!" "err" && return 1     # should never happen
          map="-i \"$subsfile\" $F_SUBS $map"
          echo;echo "Final subs map is $map"
          echo
        fi
      else
        logit "Skipping subtitles in $main per command" "info"
      fi

      # subs only - for manual recovery
      [ $j -eq 1 ] && rm -f "$tmpts" && logit "Subtitles now available in $subsfile" "info" && return 2

      # Main AV stream(s). Lose any subs here, as they won't (all) copy in ONE go, nice as that would be!
      # Also required to ensure streams sync properly when combined. 

      # Need copyts on main streams to sync subs when present.  But can cause ffmpeg to exit early if no subs or DTS issues
      [ "$F_SUBS" ] && copyts="-copyts" || copyts=""

      # V2: added "-fflags +genpts" as some mpeg2 video streams don't have timestamps causing ffmpeg to complain
      # Lack of timestamps can cause jerky playback. But likely to mess up broken recordings - particularly creating mp4
#      [ $ext != "mp4" ] && genpts="-fflags +genpts" # || genpts=""
      genpts="-fflags +genpts"

      main="$tempdir/main.ts"
      cmd="$ffmpeg $genpts -i "\"$tmpts"\" $copyts -c:v copy -c:a copy -sn -dn -map 0:u "\"$main"\""
      echo "Extracting main streams with $cmd"
      sh -c $cmd
      if [ $? -ne 0 ]; then
        logit "Fail: ffmpeg problem extracting main streams of $main (VDR 1.x), deleting (check $LOGFILE)" "err"
        if [ $debug -eq 0 ]; then
          rm -f $main || logit "could not remove $main" "err"
        fi
        return 1
      fi
      if [ $debug -eq 0 ]; then
        rm -f "$tmpts" || logit "could not remove $tmpts" "err"
      fi
      map $main 0                   # Additive map (add in subs file/map as reqd). NOTE Loses F_SUBS !
      ret=$?
      [ $ret -gt 0 ] && return $ret # same or higher vcodec
    fi
    #end VDR1.x
  else
    # VDR2
    progduration $main
    program_duration=$(($program_duration + $duration))   # combine all files.
    map $main 0
    ret=$?
    [ $ret -gt 0 ] && return $ret   # same or higher vcodec
    if [ $subs -eq 1 ]; then
      if [ ! "$F_SUBS" ]; then
        # only report subs if there is video to support them
        [ "$F_VIDEO" ] && logit "Warning no subtitles stream found in $main: none/broken/only in ads: none converted" "warn"
      else       
        # extract subs only - for manual recovery
        [ $j -eq 1 ] && subsfile="subs.ts" || subsfile="/dev/null"
        subslength $main $subsfile
        # Quit rather than continue otherwise subs could be lost, and as subs now mapped, ffmpeg likely to fail later as well
        [ $? -ne 0 ] && logit "Fail: ffmpeg problem extracting subs stream(s) of $main, is your ffmpeg patched?" "err" && return 1
        subslen=$len
        # Now we just rely on the substest. If ffmpeg says OK, it's OK, but still warn, and just in case don't delete originals
        if [ $subslen -lt $minsubsize ]; then
          logit "Warning subtitles stream in $main is smaller than minimum expected ($subslen vs. $minsubsize kb)"
          # If VDR2, perhaps not possible to transcode with subs. Only notify further if we are deleting originals
          if [ $delete -eq 1 ]; then
            if [ $subslen -eq 0 ]; then
              # V2: now regularly seeing valid, but empty, subs streams from some broadcasters
              # like null audio streams above. In fact they are often seen in the same recording
              echo "Empty subtitles stream for $main, discarding"
            else
              # a few subs means properly suspect
              delete=0 && logit "Warning: not deleting originals for $main due to suspect subtitle stream size - please check" "err"
            fi
          fi
        fi
      fi
    else
      logit "Skipping subtitles in $main per command" "info"
    fi
    # subs only - for manual recovery
    [ $j -eq 1 ] && logit "Subtitles ready in $subsfile" "info" && return 2
  fi

  # The main conversion. 

  if [ "$F_AUDIO" ]; then     # Only if we see something meaningful (may be only audio if radio recording)
	if [ $keep -eq 1 ]; then
      # LATM multiplexing matches broadcast MPEG4 SD/HD audio streams, but can't be demuxed to plain AAC by older FFMPEG versions
      # So even if keeping (e.g. automatic VDR transcode), and no video, use plain AAC so can transcode again if req'd (e.g podcast)
      if [ "$F_VIDEO" ] && [ $vcodec -ge 264 ] && [ $(echo $F_AUDIO |grep -i "aac") ]; then
        latm="-mpegts_flags latm"     # H264/5 + AAC we use latm
        # fdk codec param(s) also need to be specially tweaked here to produce latm (mpegts flags above don't do it!)
        [ $(echo $F_AUDIO |grep -i "libfdk_aac") ] && F_AUDIO=$(echo $F_AUDIO | sed -e "s/libfdk_aac/libfdk_aac -latm 1/g")
      fi
	fi
    #copyts and content of F_SUBS is already in the map if/when req'd for VDR1.x files
    [ $framerate -eq 25 ] && dvbsystem="-mpegts_flags system_b"  #DVB not ATSC
    #muxing queue issues since ffmpeg 3.3
    cmd="$ffmpeg $debug_time -i "\"$main"\" $map $F_VIDEO $F_AUDIO $F_SUBS -f mpegts $dvbsystem $latm -max_muxing_queue_size 4000 "\"$2"\" 2>> $LOGFILE"
	echo
    # Actual conversion (slow)
	logit "Transcoding with $cmd" "info"
	sh -c $cmd
	if [ $? -ne 0 ]; then
	  logit "Fail: ffmpeg problem transcoding '$input', deleting "\"$2"\" !" "err"
      rm -f "$2" || logit "could not remove "\"$2"\"" "err"
	  return 1
	fi
    # Now re-test/compare after conversion in case ffmpeg lost some (still keep for examination in case really OK)...
    # F_SUBS for VDR2 conversions, copyts for VDR1.x. Widened tolerance due to errors when re-transcoding
    if [ "$F_SUBS" ] || [ $copyts ]; then
      subslength $2 "/dev/null"
      [ $? -ne 0 ] && return 1
      [ $(($len+90)) -lt $subslen ] && logit "Fail: ffmpeg did not process all subs for '$input' (input $subslen kb, output $len kb)" "err" && return 1
    fi
    # clean up
  else
	logit "Fail: Nothing to transcode for '$input' !" "err"
	return 1
  fi
  if [ $VDRtype ] && [ $debug -eq 0 ]; then
    rm -rf "$tempdir" || logit "could not remove $tempdir" "err"
  fi
  map=""      # clear in case we process more files

  #Report mapping to the info file
  reportedvideo=$F_VIDEO
  reportedaudio=$F_AUDIO
  return 0
}

#------------------------------------------------------------------------------
# Basic QA of the output filesize/duration to make sure it's OK
# Return 1 for a fail, else 0

function check_duration() {
  # check for duration match within 30s (empirical magic number)
  progduration $outfile
  if [ $debug -eq 0 ] && [ $(($duration + 30)) -lt $program_duration ]; then
    logit "Warning: $outfile, size $(($outputsize/$meg))M, is only $duration sec long, original $(($inputsize/$meg))M, with length detected as $program_duration sec" "err"
    return 1
  fi
  # check for silly compression ratio, or larger file, heaven forbid!)
  if [ "$F_VIDEO" ]; then
    [ $vcodec -eq 262 ] && mult=3     # MPEG original
    [ $vcodec -eq 264 ] && mult=9     # x264: 1/3 of original
    [ $vcodec -eq 265 ] && mult=12    # x265 1/4 of original
    if [ $debug -eq 0 ] && [ $(($inputsize * 3)) -gt $(($outputsize * $mult)) -o $outputsize -gt $inputsize -a $maintain -eq 0 ]; then
      logit "Warning: Suspect size of $outfile, (new $(($outputsize/$meg))M vs. original $(($inputsize/$meg))M)" "err"
      # keep converted outfile, actually it may be OK
      return 1
    fi
  else    # so must be audio only...
    mult=4  #default. ok or mp3
    [ $(echo $reportedaudio |grep -i "aac") ] && mult=3     # normal, mild compression
    [ $(echo $reportedaudio |grep -i "aac_he") ] && mult=8  # podcast usually
    [ $(echo $reportedaudio |grep -i "libopus") ] && mult=8 # podcast usually
    if [ $debug -eq 0 ] && [ $inputsize -gt $(($outputsize * $mult)) -o $outputsize -gt $inputsize -a $maintain -eq 0 ]; then
      logit "Warning: Suspect size of $outfile, (new $(($outputsize/$meg))M vs. original $(($inputsize/$meg))M)" "err"
      # keep converted outfile, actually it may be OK
      return 1
    fi
  fi
  return 0
}

#------------------------------------------------------------------------------
# V2 - EDL creation for single-use mode
# Convert marks(.vdr) to an EDL so a-n-other player can skip ads
# - Kodi or (s)mplayer can use .edl files

# marks looks like 
# 0:01:01.25 Logo start
# 0:16:29.19 Logo lost
# 0:20:50.05 moved from [0:20:59.02(31476) Logo start] by checkBlackFrameOnMark  (or doOverlapDetection...)
# ...
# 1:00:02.16 noad mark on last IFrame
#
# Kodi best describes EDL: http://kodi.wiki/view/EDL_(commercial_skipping)_and_SceneMarker_support
# Mplayer/Kodi basic format closen as simplest suitable.

# $1 is marks filename. $2 is output basename

function edl() {
  # We just pair up losts (start of ADs) and starts (resume programme) to make an EDL
  commercials=0
  local tmp lost start dif timeat
  edl=$(cat "$1")
  rm -f "$2.edl" || logit "could not remove EDL file" "err" # discard any existing
  for line in $edl;
  do
    tmp=$(echo "$line" |grep -i "logo lost"|cut -c1-15|sed 's/[^0-9:.]*//g')
    if [ $tmp ]; then
      timeat=$tmp
      lost=$(echo $tmp|tr -s '.' ':'|awk -F: '{ printf "%0.2f", ($1 * 3600) + ($2 * 60) + $3 + ($4 / rate) }' rate=$framerate)
      continue
    fi
    start=$(echo "$line" |grep -i "logo start"|cut -c1-15|sed 's/[^0-9:.]*//g'|tr -s '.' ':'|awk -F: '{ printf "%0.2f", ($1 * 3600) + ($2 * 60) + $3 + ($4 / rate) }' rate=$framerate) 
    if [ $lost ] && [ $start ]; then
      echo "$lost $start 0" >> "$2.edl" 
      dif=$(echo "$start-$lost"|bc)
      echo
      # 8 mins max commercial break
      [ ${dif%.*} -gt 480 ] && logit "$2: possible error: commerical break "$dif"s long" || echo "$2 commerical break "$dif"s long at $timeat"
      commercials=$(($commercials + 1))
      lost=""; start=""
    fi
  done
  #can be just a start & end marker pair which is no use
  if [ $commercials -lt 2 ]; then
    logit "Too few EDL marker pairs ($commercials) - no EDL file created"
    if [ $debug -eq 0 ]; then
      rm -f "$2.edl" || logit "could not remove EDL file" "err"
    fi
  fi
}

#------------------------------------------------------------------------------
# Utility functions
#------------------------------------------------------------------------------
# Upload to an ftp server for faster remote download.
# Note that ncftp is not always reliable, seems to randomly quit. 
# NCFTP debug logs don't really help

function upload() {
  logit "Uploading $1"
  sh -c "ncftpput -z -t 99 -u \"$user\" -p \"$pass\" \"$server\" \"$ftppath\" \"$1\" 1>&2 &"
}

function usage() {
  echo "usage: $0 --input-path | -i \"<recording.rec>\" [--keep |-k] [--combine |-c] [--delete |-d] [--acodec |-a aac|libfdk_aac|libmp3lame] [--vcodec |-v 264|265] [--format |-f <extension>] [--extras |-e \"<ffmpeg opts>\"] [--just-subs |-j] [--nosubs] |-n] [--life |-l <days>] [--maintain |-m] |--quality |-q <CRF>] [--yadif |-y 0|1] [--tsonly |-t] [--crop-top <lines>] [--ftp] [--ftp-path <target path>] [--redo] |-r ] [--server |-s] [--user |-u] [--pass |-p] [--podcast <target-path>] [--genrefile |-g <path/file>]"
}

function escape_apostrophe() {
   echo $($1 | sed 's/"/\\\"/g')
}

# return key=value, escaped, but only if the value exists (alert missing ones)
function create_meta() {
#   [ "$2" ] && echo "-metadata $1=\"$(echo $2|sed -e 's/[;\]//g'|sed "s/'/\\\'/g"|sed 's/"/\\\"/g')"\"||echo "NOTE: -metadata $1 is missing" 1>&2
   [ "$2" ] && echo "-metadata $1=\"$(echo $2|sed -e "s/&quot;/\\\'/g"|sed -e 's/[;\]//g'|sed "s/\"/'/g")"\"||echo "NOTE: -metadata $1 is missing" 1>&2
}

function Repeat() {
  printf "%${2}s\n" | sed "s/ /${1}/g" 
}

# $1 the is message, $2 is criticality. Now optionally email errors
function logit() {
  crit=$2
  [ -z "$crit" ] && crit="warn"    # default
  logger -s -p "$log_facility.$crit" -t vdr-convert "$1"
  [[ $crit = "err" ]] && [ "$email" ] && echo $1 | mail -s "vdr-convert error" $email
  return 0
}

function cleanup() {
  cmd="rm -f $TMPFILES"
  if [ $debug -eq 0 ]; then
    sh -c $cmd || logit "could not remove file(s)" "err"
  else
    echo "Without debug command=$cmd"
  fi
  return 0
}

# return code 0 is OK, some stats to report, 2 is OK, but we did nothing/no meaningful stats, 1 is some kind of error
function quit() {
  rm -f "$LOCKFILE" || { logit "failed to delete $LOCKFILE" "err"; exit 1; }
  echo
  [ $1 -eq 2 ] && exit 0
  if [ $1 -eq 0 ]; then
    [ $redo -eq 0 ] && quitmsg=", Runtime: $(printf "%02d:%02d:%02d" $(($SECONDS / 3600))  $((($SECONDS / 60) % 60)) $(($SECONDS % 60))) ($(printf "%.2f" $(echo "$duration/$SECONDS"|bc -l))X)"
    logit "Completed: $BASENAME$quitmsg"
  fi
  exit $1
}

#------------------------------------------------------------------------------
# Start of script
#------------------------------------------------------------------------------

while [ "$1" != "" ]; do
    case $1 in
        -i | --input )          shift
                                input="$1"
                                ;;
        --debug )               debug=1
                                debug_time="-t 00:02:00"
                                ;;
        --crop-top )            shift
                                top=$(echo "$1"|sed -e 's/[^0-9]//g')
                                ;;
        -a | --acodec )         shift
                                acodec=$(echo "$1"|sed -e 's/[^a-z0-9_]//g')
                                ;;
        -v | --vcodec )         shift
                                vcodec=$(echo "$1"|sed -e 's/[^0-9]{3}//g')
                                ;;
        -c | --combine )        combine=1
                                ;;
        -d | --delete )         delete=1
                                ;;
        -e | --extras )         shift
                                extras="$1"
                                ;;
        -f | --format )         shift
                                ext=$(echo "$1"|sed -e 's/[^a-z0-9]//g')
                                ;;
        -g | --genrefile )      shift
                                genrefile=$(echo "$1"|sed -e 's/[^A-Za-z0-9._-/]//g')
                                ;;                               
        -j | --just-subs )      j=1
                                combine=1
                                ;;
        -k | --keep )           keep=1
                                quality=$quality_k
                                stereobitrate=$stereobitrate_k
                                ;;
        -l | --life )           shift
                                life=$(echo "$1"|sed -e 's/[^0-9]//g')
                                ;;
        -m | --maintain )       maintain=1         # copy streams to new container, don't transcode
                                ;;
        -n | --nosubs )         subs=0
                                ;;
        -q | --quality )        shift
                                quality=$(echo "$1"|sed -e 's/[^0-9.]//g')
                                ;;
        -y | --dif )            shift
                                dif=$(echo "$1"|sed -e 's/[^0-9]//g')
                                ;;
		-t | --tsonly )			ts=1
								;;
        -r | --redo )           redo=1
                                ;;
        --ftp  )                ftp=1
                                ;;
		--ftp-path )			shift
								ftppath=$(echo "$1"|sed -e 's/[^A-Za-z0-9._-/]//g')   # sanitise dir/file
								;;
        -s | --server )         shift
                                server="$1"
                                ;;
        -u | --user )           shift
                                user="$1"
                                ;;
        -p | --pass )           shift
                                pass="$1"
                                ;;
        --podcast )             shift
                                podcast=$(echo "$1"|sed -e 's/[^A-Za-z0-9._-/]//g')
                                ;;
        -h | --help )           usage
                                exit 0
                                ;;
        * )                     usage
                                exit 1
    esac
    shift
done

Repeat - 120 
echo

[ $vcodec -lt 264 ] || [ $vcodec -gt 265 ] && usage && exit 1
[ $ext == "mp3" ] && acodec="libmp3lame"

# ffmpeg exists?
command -v $ffmpeg >/dev/null 2>&1 || { echo "$0 requires 'ffmpeg' but it's not in the path/config,  Aborting."; exit 1; }
ffmpegbuild=$($ffmpeg 2>&1)  # get build options to check feature compatibility

[ $vcodec -eq 264 ] && [ ! $(echo $ffmpegbuild | grep 'libx264') ] && logit "$0 requires ffmpeg built with at least libx264" && exit 1
[ $vcodec -eq 265 ] && [ ! $(echo $ffmpegbuild | grep 'libx265') ] && logit "ffmpeg is not built with libx265" && exit 1
[ $acodec = "libfdk_aac" ] && [ ! $(echo $ffmpegbuild | grep 'libfdk') ]  && logit "ffmpeg is not built with libfdk_aac for AAC" && exit 1
[ $acodec = "libmp3lame" ] && [ ! $(echo $ffmpegbuild | grep 'libmp3lame') ]  && logit "ffmpeg is not built with libmp3lame for MP3" && exit 1

# create deep probes
ffmpeg="nice -n 19 "$ffmpeg" -y -hide_banner -nostats -probesize 250M -analyzeduration 600M -copytb 1"

[ ! -d "$input" ] && logit "Recording directory '$input' doesn't exist!" && exit 1
[ $dif ] && [ $dif -gt 1 ] && echo "deinterlacer config must be 0 or 1" && usage && exit 1

if [ $keep -eq 1 ]; then
  command -v vdr >/dev/null 2>&1 || { echo "$0 requires 'vdr' but it's not in the path,  Aborting."; exit 1; }
#  [ $ext != 'ts' ] && echo "$ext format not directly supported by VDR" && exit 1
fi

xmit=$(($ftp + $redo))
if [ $xmit -gt 0 ]; then
  command -v ncftpput >/dev/null 2>&1 || { echo "$0 FTP functions require 'ncftp' but it's not in the path/config,  Aborting."; exit 1; }
  [ $xmit -gt 1 ] && { echo "$0 Cannot FTP and Redo! - Aborting."; exit 1; }
fi

# *** Adjustments to interdependent parameters ***

[ $ext == "mp4" ] || [ $ext == "avi" ] && [ $subs -eq 1 ] && subs=0 && logit "Warning: subs not supported in $ext format: discarded if present" "warn"
[ $top -gt 0 ] && [ $maintain -eq 1 ] && echo "Can't crop without re-encoding" && exit 1

# help Fraunhofer codec produce full(er) range - default cutoff 14kHz @low bitrates.
[ $acodec == "libfdk_aac" ] && acodec="$acodec -cutoff 17000"

if [ "$podcast" ]; then
  [ ! -d "$podcast" ] && logit "Podcast directory '"$podcast"' doesn't exist!" && exit 1
  outputdir=$podcast
else
  outputdir=$(pwd)    # current dir is default
fi
[ ! -w $outputdir ] && logit "Can't write to output directory" "err" && exit 1

[ "$genrefile" ] && [ ! -f "$genrefile" ] && logit "Genre definitions file '"$genrefile"' doesn't exist!" && exit 1

# VDR has been known to "start/stop" multiple times at the end of a recording (VPS?) - so prevent multiple instances
LOCKFILE="$input/vdr-convert.pid"

# check for existing lockfile
if [ -e "$LOCKFILE" ]; then
  # lockfile exists
  [ -r "$LOCKFILE" ] || { logit "Error: cannot read lockfile"; exit 1; }
  PID=$(cat "$LOCKFILE")
  kill -0 "$(cat "$LOCKFILE")" 2>/dev/null && logit "Error: existing instance of $0 is already running, exiting" && exit 1
  # process that created lockfile is no longer running - delete lockfile
  rm -f "$LOCKFILE" || { logit "Error: failed to delete $LOCKFILE"; exit 1; }
fi

# create lockfile
echo $$ >"$LOCKFILE" || { logit "Error: cannot create lockfile for $0"; exit 1; }

# VDR filetypes 1.x (PES) or 2.x (TS), based on filenames in recording directory

#vdrfiles=(`find "$1" -type f -name '*.vdr' | wc -l`)
#tsfiles=(`find "$1" -type f -name '*.ts' | wc -l`)
vdrfiles=0; tsfiles=0
vdrfiles=($(ls -1 "$input" | grep ".vdr$" |grep -o '[0-9]\{3\}'| wc -l))
tsfiles=($(ls -1 "$input" | grep ".ts$" |grep -o '[0-9]\{5\}'| wc -l))
# must have 1 data file min, ideally an info file. We don't care about index file here
[ $vdrfiles -lt 1 -a $tsfiles -lt 1 ] && logit "vdr=$vdrfiles,ts=$tsfiles : too few recording / info files!" "err" && quit 1

# Assume there are multiple files, as merging is v. quick
if [ $vdrfiles -gt 0 ]; then
 VDRtype=".vdr"
 FILES="$input/0*.vdr"
else 
 VDRtype=""
 FILES="$input/0*.ts"
fi

if [ $VDRtype ]; then
  [ $ts -eq 1 ] && logit "Skipping '$input', t flag and not an mpegts (VDR2.x) recording" && quit 2
  command -v genindex >/dev/null 2>&1 || { echo "$0 requires 'genindex' for VDR1.x conversions, but it's not in the path,  Aborting."; quit 1; }
  command -v iso13818ts >/dev/null 2>&1 || { echo "$0 requires 'iso13818ts' for VDR1.x conversions, but it's not in the path,  Aborting."; quit 1; }
fi

logit "Processing '$input' (files=$(($vdrfiles + $tsfiles))), keep=$keep, delete=$delete, combine=$combine, format=$ext, subs=$subs, extras=$extras, podcast dir=$podcast" "info"

#------------------------------------------------------------------------------
# Get all relevant metadata out of the info(.vdr) file, if it exists
#------------------------------------------------------------------------------

[ -e "$input/info$VDRtype" ] && meta=$(cat "$input/info$VDRtype")

TITLE="NO TITLE"
pod_desc="No Description"

[ "$meta" ] && for line in "$meta";
do
  #naming
  TITLE=$(echo "$line" |grep "^T" |sed -e "s/^T //")
  # optional fields - add them for improved ID
  ID[0]=$(echo "$line" |grep "^S" |sed -e "s/^S //")  #subtitle
  # Support filesystems with limited max filename size by truncating just subtitle
  l=$((${#TITLE} + ${#ID[0]}))
  [ $l -ge $filesystem ] && ID[0]=$(echo $ID[0] |cut -c1-$filesystem)...
  EP=$(echo "$line" |grep "^D" |grep -oP '(?<=Episode: ).*' |cut -f1 -d"|")
  # EP1 is Schedules Direct/Tribune source data: not fully defined. 
  # eg. MV001234560000. First 8 numbers appear to be progID. others EP
  # See Tribune media XTVDSchemaDefinition.pdf. Limited decoding info!
  # "Uniquedescriptionidentifier necessary to reference movies, shows, episodes, sports from the programs
  # data. First two digits are alphanumeric and correspond to movies (MV), shows(SH), episodes(EP) and sports(SP).
  # For shows beginning with EP, the next 8 digits represent the seriesID, with the last 4 digits representing
  # the episodeid. If episode information is not available, the program will appear as type SH, the next 8 digits
  # as the series id and the last 4 digits as zeros."

  EP1=$(echo $EP | grep -oP '[A-Z]{2}[0-9]{10,12}')
  EP2=$(echo $EP | grep -oP '[0-9/ ]{1,3}\.[0-9/ ]{1,3}\.[0-9/ ]{0,3}')   # xmltv, e.g 2 . 9/10 . 0/1
  EP2=$(echo $EP2 | tr -d ' ')
  # Meta info event date, time and DOW, 3rd field - useful in file listings for offline use
  ID[2]=$(echo "$line" |grep "^E" |cut -f3 -d" " |awk '{print strftime("%F-%a_%H-%M",$1)}')
 
  #resolution. Just look for HD in station name - a bit simplistic, but only used for file naming
  CHAN=$(echo "$line" |grep "^C" |cut -f3-7 -d" ")
  HD=$(echo "$CHAN" |grep -o 'HD')
  fr=$(echo "$line" |grep "^F"|sed 's/[^0-9]*//g')
  [ $fr ] && framerate=$fr    # when provided

  #Stream metatdata also. 
  #Video - useful to know if recording contains any. ffmpeg test rather than use actual values
  X1=$(echo "$line" |grep "^X [1\|5\|9]" |cut -f4 -d" ")

  #Audio
  X201=$(echo "$line" |grep "^X 2 [01\|02]" |cut -f4 -d" ")
  X203=$(echo "$line" |grep "^X 2 03" |cut -f4 -d" ")
  X204=$(echo "$line" |grep "^X 2 04" |cut -f4 -d" ")
  X205=$(echo "$line" |grep "^X 2 05" |cut -f4 -d" ")
  X240=$(echo "$line"|grep "^X 2 40" |cut -f4 -d" ")  # AD
  X31=$(echo "$line" |grep "^X 3 1" |cut -f4 -d" ")   # teletext/subs

  #Podcast tags
  #There may be a year field in the description. Or use year of recording, assuming not a repeat!
  pod_date=$(echo "$line" |grep "^D" |grep -oP '(?<=Date: ).*' |cut -f1 -d"|" |grep -oP '[0-9]{4}')
  pod_year=$(echo "$line" |grep "^E" |cut -f3 -d" " |awk '{print strftime("%Y",$1)}')
  pod_week=$(echo "$line" |grep "^E" |cut -f3 -d" " |awk '{print strftime("%V",$1)}')
  pod_genrenum=$(echo "$line" |grep "^G" |cut -f2 -d" ")
  pod_presenters=$(echo "$line" |grep "^D" |grep -oP '(?<=Presenters: ).*' |cut -f1 -d"|")   # rarely
  pod_actors=$(echo "$line" |grep "^D" |grep -oP '(?<=Actors: ).*' |cut -f1 -d"|")   # often
  pod_desc=$(echo "$line" |grep -oP '(?<=^D ).*' |cut -f1 -d"|")  # almost always, sadly usu. freeform!
  
  lifetime=$(echo "$line" |grep "^L" |sed 's/[^0-9]*//g')
done

if [ $VDRtype ]; then
  ROOTDIR=$(echo $(dirname "$input"))
  BASEDIR=$(echo $(basename "$input"))
  priority=$(echo $BASEDIR | cut -f4 -d".")
  lifetime=$(echo $BASEDIR | cut -f5 -d".")   # overwrite it
fi

# Manage short lifetime recordings
if [ $lifetime -lt $life ]; then
  # TV recordings skipped if we are "keeping" them - save time & energy
  [ "$X1" ] && [ $keep -eq 1 ] && logit "Skipping '$input', recording lifetime is $lifetime" "info" && quit 2
elif [ $lifetime -gt $life ]; then
  # Only make (radio) podcasts if they are short life, else normal
  if [ ! "$X1" ] && [ "$podcast" ]; then
    podcast=""
    outputdir=$(pwd)
    logit "Not making podcast of '$input', recording lifetime is $lifetime : transcoding normally" "warn"
  fi
fi

# Postprocess the various tags

# There are often multiples, take the first - naff, I know
IFS=' ' read -ra X201 <<<"$X201"
[ $X201 ] && Alangmono=$X201
IFS=' ' read -ra X203 <<<"$X203" 
[ $X203 ] && Alangstereo=$X203
IFS=' ' read -ra X204 <<<"$X204" 
[ $X204 ] && Alangmulti=$X204
IFS=' ' read -ra X205 <<<"$X205" 
[ $X205 ] && Alangsurround=$X205
IFS=' ' read -ra X240 <<<"$X240"
[ $X240 ] && ADlang=$X240
IFS=' ' read -ra X31 <<<"$X31" 
[ $X31 ] && Slang=$X31

# override rec date by meta if we have it
[ "$pod_date" ] && pod_year=$pod_date 
# Other meta fallbacks
[ ! "$pod_presenters" ] && [ "$pod_actors" ] && pod_presenters=$pod_actors
[ ! "$pod_presenters" ] && [ "$CHAN" ] && pod_presenters=$CHAN

#prioritise EP2, remember xmltv numbering is zero based
if [ "$EP2" ]; then
  ID[1]="EP:$EP2"  # Note for historical consistency this is the RAW unprocessed value
  pod_episode_id=$EP2   # This tag will be complete - gives parts + total ep count if required
  pod_album=$(echo $EP2 | grep -oP '^[0-9]{1,3}')
  pod_album="$(($pod_album + 1)) ($pod_year)"
  pod_episode=$(echo $EP2 | cut -f2 -d'.' | grep -oP '^[0-9]{1,3}')    # ignore last parts element: very rarely seen
  pod_episode=$(($pod_episode + 1))
elif [ "$EP1" ]; then
  ID[1]="EP:$EP1"
  pod_episode_id=$EP1
  pod_album=$pod_year
  pod_episode=$pod_week    # ISO 8601 week no. - numeric.
else
  pod_album=$pod_year
  pod_episode=$pod_week
fi

# The description may contain the "Category" (i.e.genre), but on radio often doesn't: so do it the hard way!
# Find *first* match for the Genre as text (VDR info provides Genrenum as a number)
pod_genre=$pod_genrenum     # a default fallback - why not ? (e.g. genre file missing) 
if [ "$podcast" ] && [ "$genrefile" ] && [ $pod_genrenum ]; then
  while read -r line; do
    [ $(echo "$line" | grep '^ *#') ] && continue  #skip comments
    [ $(echo "$line" | grep ":$pod_genrenum") ] && pod_genre=$(echo "$line" | cut -f1 -d":") && break
  done < "$genrefile"
fi

LONGTITLE=$TITLE
for token in ${ID[@]}
do
  [ "$token" ] && LONGTITLE=$(echo "$LONGTITLE-$token")
done

# Option to combine input files:
# By default we transcode files separately, in case a broken file fails. Combining might be less reliable,
# esp. with lots of interruptions, ffmpeg duration estimations can often get messed up.
# But results are completely seamless when combined - so it's recommended when recordings are reliable
if [ $combine -eq 1 ] && [ $vdrfiles -gt 1 -o $tsfiles -gt 1 ] && [ $redo -eq 0 ]; then
  # Avoid concatting Gb of HD files if not req'd - do a quick check of first file. May map raw .vdr files!
  file1=$(echo $FILES |cut -f1 -d" ")
  map $file1 0
  ret=$?
  [ $ret -gt 0 ] && quit $ret       # if same or higher vcodec
  # this might not find video (short files) - it will fall through
  map=""
  cat $FILES > "$input/recording.orig"
  if [ $? -eq 0 ]; then
    FILES="$input/recording.orig"
  else
    logit "Failed to combine input files for '$input', trying individually" && rm -f "$input/recording.orig"
  fi
fi

#------------------------------------------------------------------------------
# Conversion
#------------------------------------------------------------------------------
# We can be presented with recording.orig or a list of files in FILES. 
# recording.orig may not be large enough either - still size test it

for f in $FILES
do
  size=$(stat -c %s "$f" )
  if [ $size -gt $minsize ]; then
    inputsize=$(($inputsize + $size))
    fileno=$(($fileno + 1))
    echo; Repeat - 120
    logit "Processing \"$f\" file $fileno, size $(($size/$meg))M..." "info"
    OUTFILE="$input/intermediate-file-$fileno.ts"
    TMPFILES=$(echo "$TMPFILES \"$OUTFILE"\")
    MERGEFILES=$(echo "$MERGEFILES$OUTFILE|")
    if [ $redo -eq 0 ]; then
      transcode "$f" "$OUTFILE"
      return=$?
      if [ $debug -eq 0 ] && [ $combine -eq 1 ] && [ -e "$input/recording.orig" ]; then
        rm -f "$input/recording.orig" || logit "could not remove '$input/recording.orig'" "err"
      fi
      [ $return -gt 0 ] && quit $return
    fi
  else
    # combined or not, it's too small
    echo
    if [ $combine -eq 1 ]; then
      if [ $vdrfiles -eq 1 -o $tsfiles -eq 1 ] && [ $delete -eq 1 ]; then
        # Special logic here to delete first file in case it's an aborted VPS start. 
        # The combine flag is really forcing a special cleanup mode here
        logit "Deleting short initial recording file: $f, too small ($(($size/$meg))M)" "err"
        rm -f "$f" || logit "could not remove $f" "err"
        quit 1
      fi
      logit "Skipping $f - combined size too small ($(($size/$meg))M)" "err"
      quit 1
    fi
    logit "Skipping $f - too small ($(($size/$meg))M). Try combining input files with -c option" "err"
    # !!!continue but no longer delete (so don't lose anything if it all goes wrong)
    [ $keep -eq 1 ] && [ $delete -eq 1 ] && delete=0 && logit "No longer deleting files for '$input'"
  fi
done

# Map the last output file
# Why? Sometimes a stream actually has no content (e.g. AD or subs),
# even if the stream notionally existed when probed, ffmpeg usually drops it silently if empty,
# resulting in a different map in the output file. The transcode function may also drop null streams
# ffmpeg still needs a specific map to copy more than just "the best" single audio & video stream.
# For VDR1.x conversions, this also fixes the output stream mapping order 
# (audio and subs first -> video, "best" audio, other audio, subs)
# NOTE this assumes map of each transcoded file is the same, otherwise there will be trouble.

map=""
map $OUTFILE 0 1  # usu. a temp file

# SD or HD?. Enhanced EPG would tell us - but not always present
if [ $F_VIDEO ]; then
  DEF=$HD
  [ ! $DEF ] && DEF="SD"
else
  [ $F_AUDIO ] && DEF="AUDIO"
fi

#------------------------------------------------------------------------------
# Merge transcoded files
#------------------------------------------------------------------------------
# Now merge and name them where required, avoid faffing about with separate files
# Concat supports some file format (container) conversions and filters, but not stream conversions
# Some filters are auto-enabled depending on output format, e.g. m4a invokes aac_adtstoasc, so I no longer need to!
# see https://www.ffmpeg.org/ffmpeg-bitstream-filters.html

# Extensive recording metadata is also inserted here

BASENAME=$(echo "$LONGTITLE" | tr -s "\/:?*<>\"|" '-')   # filenames with rec date - no special chars (prev. no spaces too)
TITLE=$(echo "$TITLE" | tr -s "\/:?*<>\"|" '-')          # directories - no special chars

if [ $keep -eq 1 ]; then   
  OUT[0]="$input/$BASENAME.ts"    # intermediate file before rename
else
  # On a "redo" can't test for type, so only use basename when ftp'ing
  [ $ftp -eq 0 -a $redo -eq 0 -a ! "$podcast" ] && BASENAME="$BASENAME-$DEF"
  if [ $debug -eq 1 ] && [ $ext == "ts" ]; then     # i.e. default, no ext spec'd
    # loop through and create desired formats for testing (allow multiple versions to exist by naming)
    if [ $DEF == "AUDIO" ]; then
      BASENAME="$BASENAME-$acodec"
      [ $(echo $acodec |grep -i "libmp3") ] && formats=(mp3 mkv ts) || formats=(m4a mkv mp4 ts)
    else
      BASENAME="$BASENAME-H$vcodec-$acodec"
      # Will fail on mp4 & avi if you concat with them as formats don't support subs
      [ "$F_SUBS" ] || [ $copyts ] && formats=(mkv mov m2ts ts) || formats=(avi mkv mp4 mov m2ts ts)
    fi
  else
    formats=($ext)
  fi
  if [ "$podcast" ]; then
    # use the Title to help organise podcast files (fallback if cannot)
    mkdir -p -- "$outputdir/$TITLE"
    if [ $? -ne 0 ]; then
      logit "Cannot create directory $outputdir/$TITLE, falling back to $outputdir" "warn"
    else
      outputdir="$outputdir/$TITLE"
    fi      
  fi 
  for ((i=0; i<${#formats[*]}; i++));
  do
    OUT[i]="$outputdir/$BASENAME.${formats[i]}"
  done
  # if marks present, convert to an EDL file
  [ -f "$input/marks$VDRtype" -a $redo -eq 0 ] && edl "$input/marks$VDRtype" "$outputdir/$BASENAME"
fi

if [ $MERGEFILES ]; then
  result=0; results=0
  # Do merge(s)
  for outfile in ${OUT[@]}
  do
    if [ $redo -eq 0 ]; then
      # add tag parameters for all recordings now (not just podcasts)
      # A number of these are gross approximations as metadata is poor - e.g. Album artist
      # language a bit approximate: individual streams have language tags, but not always shown
      # Title has description concatenated so it shows in LMS scrolling title display - as some podcasts
      # MP4 likes "date" not "year" (ffmpeg docs wrong atm)
      # ts has no metadata, ffmpeg silently drops
      metadata=" \
      "$(create_meta "service_provider" $CHAN)"\
      "$(create_meta "title" "$LONGTITLE: $pod_desc")"\
      "$(create_meta "year" $pod_year)"\
      "$(create_meta "date" $pod_year)"\
      "$(create_meta "album" $pod_album)"\
      "$(create_meta "track" $pod_episode)"\
      "$(create_meta "author" $pod_presenters)"\
      "$(create_meta "artist" $pod_presenters)"\
      "$(create_meta "album_artist" $TITLE)"\
      "$(create_meta "genre" $pod_genre)"\
      "$(create_meta "episode_id" $pod_episode_id)"\
      "$(create_meta "show" $TITLE)"\
      "$(create_meta "description" $pod_desc)"\
      "$(create_meta "comment" $pod_desc)"\
      "$(create_meta "language" $Alangstereo)"\
      "$(create_meta "publisher" $CHAN)"\
      -metadata encoder=\"vdr-convert\"\
      -metadata encoded_by=\"vdr-convert\"\
      "

      #ts's can be concatenated directly. Again probe deeply else can fail, esp. on AD/subs.
      # NOTE concat file better than concat stream: lipsync issues
      # -copyts??? Without it ffmpeg reports duration correctly. Possibly not with copyts
      cmd="$ffmpeg -i concat:"\"$MERGEFILES"\" $metadata -c copy $concatflags $map "\"$outfile"\" 2>> $LOGFILE"
      echo; Repeat - 120
      logit "Creating output with $cmd" "info"
      sh -c $cmd
      result=$?
      [ $result -eq 0 ] && msg="OK" || msg="Fail"
      outputsize=$(stat -c %s "$outfile") || outputsize=1   # 1 file, safety if null
      stats="$(($inputsize/$meg))M to $(($outputsize/$meg))M ($(echo $outputsize $inputsize | awk '{ printf "%.1f", 100 * $1 / $2 }')%)"
      [ $keep -eq 0 ] && echo && logit "Created $outfile ($stats), $msg" "info"
      results=$(($results + $result))
    else
      results=$redo
    fi
  done
  if [ $results -eq 0 ]; then
    check_duration       # basic QA
    [ $? -ne 0 ] && cleanup && quit 1
    # Extensive QA testing only when keeping
    if [ $keep -eq 1 ]; then
      # Save video, force a VDR reindex and check it was really successful before deleting original files
      # VDR2 will only recognise .ts's in the NEW format of directory name
      if [ $VDRtype ]; then
        # Need a new recording DIR formatted for VDR2/ts files, else VDR2 won't see it
        # TV channel starts at 1. Channel number unavailable in info.vdr (& can change), just set to 1
        # Resume ID 0 as resume different in VDR1.x
        RECDIR=$(echo "$BASEDIR" | cut -f1-3 -d".")
        RECDIR="$ROOTDIR/$RECDIR.1-0.rec"
        mkdir -p -- "$RECDIR"
        if [ $? -ne 0 ]; then
          logit "Failed - cannot create $RECDIR" "err"
          cleanup
          quit 1
        fi
        # marks don't need to change - they are time-related not stream related
        [ -f "$input/marks.vdr" ] &&  cp -f "$input/marks.vdr" "$RECDIR/marks"	
        # Add the priority and Lifetime tags to new info
        cp -f "$input/info.vdr" "$RECDIR/info"
        echo "P $priority" >> "$RECDIR/info"
        echo "L $lifetime" >> "$RECDIR/info" 		
        # no resume as format changed
      else
        # VDR2 - Save ts's and index
        RECDIR="$input"
        SAVE="$input/0*.ts"
        for f in $SAVE
        do
          mv -n "$f" "$f.orig" || logit "could not save original file(s)" "err"   # don't overwrite!
        done
        mv -n "$input/index" "$input/index.orig" || logit "could not save index" "warn"
      fi
      # Only a single ts after transcoding, (VDR will only check the file having replaced the originals!)
      mv -f "$outfile" "$RECDIR/00001.ts" || logit "could not move .ts" "err"
      # Neatness, but importantly a check that VDR will be reasonably happy to play the file - otherwise bail
      sh -c "vdr --genindex "\"$RECDIR"\""
      if [ $? -eq 0 ]; then
        echo "# Transcoded from $stats by $0 on $(date)" >> "$RECDIR/info"
        [ "$F_VIDEO" ] && echo "# Video parameters: $reportedvideo" >> "$RECDIR/info"
        [ "$F_AUDIO" ] && echo "# Audio parameters: $reportedaudio" >> "$RECDIR/info"
        logit "Created/replaced .ts and indexed $BASENAME ($stats)" "info"
        if [ $delete -eq 1 ]; then
          if [ $VDRtype ]; then
            # old VDR 1.x directory & content no use now
            if [ $debug -eq 0 ]; then
              rm -rf "$input" || logit "could not remove original file(s)" "err"
            fi
          else
            if [ $debug -eq 0 ]; then
              rm -f "$input"/*.orig || logit "could not remove original file(s)" "err"
            fi
          fi
          logit "Original files for $BASENAME deleted" "info"
        fi
      else
        # Failed, so restore
        logit "Conversion / indexing for $BASENAME failed" "err"
        if [ $VDRtype ]; then
          if [ $debug -eq 0 ]; then
            rm -rf "$RECDIR" || logit "could not delete temp conversion files"    # borked new directory
          fi
        else
          # Overwrite
          mv -f "$RECDIR/index.orig" "$RECDIR/index" || logit "could not restore index"
          for f in $SAVE
          do
            mv -f "$f.orig" "$f" || logit "could not restore original video file"
          done
        fi
      fi
    #end keep mode
    else
      # We've done reasonable, but not exhaustive checks - delete podcast originals if requested
      if [ "$podcast" ] && [ $debug -eq 0 ]; then
        if [ $delete -eq 1 ]; then
          rm -rf "$input" || logit "could not remove original files" "err"
          logit "Original files for $BASENAME deleted" "info"
        fi  
		# Post conversion command(s) as required
		[ $podcastcmd ] && sh -c "$podcastcmd" &
      fi
    fi
  else 
    [ $redo -eq 0 ] &&  logit "Fail: Converted files for $BASENAME did not merge correctly" "err"
  fi
  cleanup
fi

# FTP upload or re-upload if required
if [ $ftp -eq 1 -o $redo -eq 1 ]; then
  [ -e "$outputdir/$BASENAME.edl" ] && upload "$outputdir/$BASENAME.edl"
  [ -e "$outfile" ] && upload "$outfile"
fi

# remove lockfile
quit 0

# --------- $Id: vdr-convert,v 2.2 2018/09/12 12:10:10 richard Exp $ ---------- END
